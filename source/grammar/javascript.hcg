@IGNORE g:sp g:nl tk:comment

@IMPORT default-productions as def

@EXPORT javascript as js
@EXPORT expression as exp
@EXPORT statement_list_item as stmt

####################

f:BindingExpression { { type:env.typ.BindingExpression, symbol:"=", nodes: [$1, $2],  pos  } }

f:Spread{ { type:env.typ.Spread, nodes: [$2],  pos  } }

######################################################################p#########################################
###############################################################################################################
###############################################################################################################
# Productions
###############################################################################################################
###############################################################################################################
###############################################################################################################

<> javascript > module                                                                                                  
                                                    f:r { { type:(env.IS_MODULE) ? env.typ.Module : env.typ.Script, nodes:$1 || [], pos  } }

###############################################################################################################
###############################################################################################################
## SCRIPT
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-ecmascript-language-scripts-and-modules
###############################################################################################################

<> script > script_body                                                                                     
                                                    f:r { { type:env.typ.Script, nodes:$1, pos } }

<> script_body > statement_list      

### Meta

<> comment > \/* ( g:sp | g:nl | g:id | g:num | g:sym )(*) \*/
    | \// ( g:sp | g:id | g:num | g:sym )(*) ( g:nl | ?=$eof ) 


###############################################################################################################
###############################################################################################################
## MODULES
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-ecmascript-language-scripts-and-modules
###############################################################################################################

<> module > module_body      

<> module_body > module_item(+)                                                                         

<> module_item > import_declaration
                                                    f:r{ env.IS_MODULE = true, $1 }
    | export_declaration
                                                    f:r{ env.IS_MODULE = true, $1 }
    | statement_list_item

###############################################################################################################
# https://262.ecma-international.org/12.0/#prod-ImportDeclaration
###############################################################################################################

<> import_declaration > t:import import_clause from_clause asi                                              
                                                    f:r { { type:env.typ.ImportDeclaration, nodes:[$2, $3], pos } }
    | t:import module_specifier asi                                                                             
                                                    f:r { { type:env.typ.ImportDeclaration, nodes:[$2], pos } }

<> import_clause > imported_default_binding                                                                 
                                                    f:r { { type:env.typ.ImportClause, nodes:[$$1], pos } }
    | name_space_import                                                                                         
                                                    f:r { { type:env.typ.ImportClause, nodes:[$$1], pos } }
    | named_imports                                                                                             
                                                    f:r { { type:env.typ.ImportClause, nodes:[$$1], pos } }
    | imported_default_binding , name_space_import                                                              
                                                    f:r { { type:env.typ.ImportClause, nodes:[$$1, $$3], pos } }
    | imported_default_binding , named_imports                                                                  
                                                    f:r { { type:env.typ.ImportClause, nodes:[$$1, $$3], pos } }

<> imported_default_binding > imported_binding                                                              
                                                    f:r { $1.type = env.typ.IdentifierDefault, $1 }

<> name_space_import > * t:as imported_binding                                                              
                                                    f:r { { type:env.typ.NameSpaceImport, nodes:[$$3], pos } }

<> named_imports > { import_specifier(*\, ) ,? }                                                            
                                                    f:r { { type:env.typ.NamedImports, nodes:$$2 || [], pos } }

<> from_clause > t:from module_specifier                                                                    
                                                    f:r { { type:env.typ.FromClause, nodes:[$2], pos } }

<> import_specifier > imported_binding                                                                      
                                                    f:r { { type:env.typ.Specifier, nodes:[$1], pos } }
    | identifier t:as imported_binding                                                                          
                                                    f:r { { type:env.typ.Specifier, nodes:[$1, $3], pos } }

<> module_specifier > string_literal                                                                        

<> imported_binding > identifier                                                                            
                                                    f:r { $1.type = env.typ.IdentifierModule, $1 }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-exports
###############################################################################################################

<> export_declaration > t:export * from_clause asi                                                          
                                                    f:r { { type:env.typ.ExportDeclaration, nodes:[null, $3], DEFAULT:false, pos } }
    | t:export export_clause from_clause? asi                                                               
                                                    f:r { { type:env.typ.ExportDeclaration, nodes:[$2, $$3], DEFAULT:false, pos } }
    | t:export variable_statement                                                                           
                                                    f:r { { type:env.typ.ExportDeclaration, nodes:[$2], DEFAULT:false, pos } }
    | ! t:export declaration                                                                                  
                                                    f:r { { type:env.typ.ExportDeclaration, nodes:[$2], DEFAULT:false, pos } }
    | ! t:export t:default hoistable_declaration                                                              
                                                    f:r { { type:env.typ.ExportDeclaration, nodes:[$3], DEFAULT:true, pos } }
    | ! t:export t:default class_declaration                                                                  
                                                    f:r { { type:env.typ.ExportDeclaration, nodes:[$3], DEFAULT:true, pos } }
    | t:export t:default  assignment_expression asi
                                                    f:r { { type:env.typ.ExportDeclaration, nodes:[$3], DEFAULT:true, pos } }

<> export_clause > { export_specifier(*\, ) ,? }
                                                    f:r { { type:env.typ.ExportClause, nodes:$$2||[], pos } }

<> export_specifier >  identifier
                                                    f:r { { type:env.typ.Specifier, nodes:[$1], pos } }
    | identifier t:as identifier
                                                    f:r { { type:env.typ.Specifier, nodes:[$1, $3], pos } }                                                                      

############################################################################################################### 
###############################################################################################################
## STATEMENTS
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://262.ecma-international.org/12.0/#prod-Statement
###############################################################################################################

<> statement_list > statement_list_item
                                                    f:r { [ $1 ] }
    | statement_list statement_list_item
                                                    f:r { [ ...$1, $2 ] }                             

<> statement_list_item > statement 
    | ! declaration


<> statement > block_statement 
    |  expression_statement
    | variable_statement
    | continue_statement
    | break_statement
    | throw_statement
    | return_statement
    | debugger_statement
    | labeled_statement
    | empty_statement
    | if_statement
    | breakable_statement
    | with_statement
    | try_statement

<> asi > ( g:rec | \; )

<[ recover asi_1 ] 

    scan back until [ g:nl ] then consume nothing then set prod to asi

    on fail state [ asi_forward_scan ] 

    scan until [ \} $eof ] then consume nothing then set prod to asi
>

<> declaration > class_declaration
    | hoistable_declaration
    | lexical_declaration

<> hoistable_declaration > function_declaration

<> breakable_statement > iteration_statement
    | switch_statement


###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-block
###############################################################################################################

<> block_statement > block                          

<> block > ! { statement_list? } 
                                                    f:r { { type: env.typ.BlockStatement, nodes: $$2 || [], pos } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-empty-statement
###############################################################################################################

<> empty_statement > ; 
                                                    f:r { { type: env.typ.EmptyStatement, pos } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-expression-statement
###############################################################################################################

<> expression_statement > expression asi 
                                                    f:r { { type: env.typ.ExpressionStatement, nodes:[$1], pos } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-expression-statement
###############################################################################################################

<> if_statement > t:if \( expression \) statement (t:else statement)? 
                                                    f:r { { type: env.typ.IfStatement, nodes:[$$3, $$5, $$6], pos } }                

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-iteration-statements
###############################################################################################################

<> iteration_statement > t:do statement t:while \( expression \) asi 
                                                    f:r { { type: env.typ.DoStatement, nodes:[$$2, $$5], pos } }

    | t:while \( expression \) statement 
                                                    f:r { { type: env.typ.WhileStatement, nodes:[$$3, $$5], pos } }

    | t:for \( (  expression                        f:r { { type:env.typ.ExpressionStatement, nodes:[$1], pos } }

    | t:var for_binding(+\, )                       f:r { { type:env.typ.VariableDeclaration, nodes:$2, pos } }
    )? ; expression? ; expression? \)  statement                                                 
                                                    f:r { { type: env.typ.ForStatement, nodes:[$$3, $$5, $$7, $$9], LEX:false, pos } }

    | t:for \( lexical_declaration expression? ; expression? \) statement                                       
                                                    f:r { { type: env.typ.ForStatement, nodes:[$$3, $$4, $$6, $$8], LEX:true, pos } }                                                                           
                                                                                                                                                                                                                                                                    
    | t:for \( (  left_hand_side_expression
        | t:var for_binding                         f:r { { type:env.typ.VariableDeclaration, nodes:[$2], pos }  }
        | for_declaration
    ) t:in expression \) statement                                                                          
                                                    f:r { { type: env.typ.ForInStatement, nodes:[$$3, $$5, $$7], pos } } 

    | t:for t:await? \( (  left_hand_side_expression
        | t:var for_binding f:r { { type:env.typ.VariableDeclaration, nodes:[$2], pos }  }
        | for_declaration
    ) t:of expression \) statement                                                                          
                                                    f:r { { type: env.typ.ForOfStatement, nodes:[$$4, $$6, $$8], pos, AWAIT:!!$$2 } }

<> for_declaration > ( t:let | t:const ) for_binding                                                               
                                                    f:r { { type: env.typ.LexicalBinding, nodes:[$$2], symbol:$$1, pos } }

<> for_binding > binding_identifier 
    | binding_pattern 

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-continue-statement
###############################################################################################################

<> continue_statement > t:continue goto_label_identifier? asi                                                    
                                                    f:r { { type: env.typ.ContinueStatement, nodes:$$2 ? [$$2] : [], pos } }  

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-break-statement
###############################################################################################################

<> break_statement > t:break goto_label_identifier? asi
                                                    f:r { { type: env.typ.BreakStatement, nodes:[$$2], pos } }


###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-return-statement
###############################################################################################################

<> return_statement > 
            t:return expression? asi
                                                    f:r { { type:env.typ.ReturnStatement, nodes:[$2], pos } }
        |   t:return g:nl
                                                    f:r { { type:env.typ.ReturnStatement, nodes:[$2], pos } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-throw-statement
###############################################################################################################

<> throw_statement > t:throw expression asi
                                                    f:r { { type:env.typ.ThrowStatement, nodes:[$$2], pos } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-with-statement
###############################################################################################################

<> with_statement > t:with \( expression \) statement
                                                    f:r { { type:env.typ.WithStatement, nodes:[$$3, $$5], pos } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-switch-statement
###############################################################################################################

<> switch_statement > t:switch \( expression \) case_block 
                                                    f:r { { type:env.typ.SwitchStatement, nodes:[$$3, $$5], pos } }

<> case_block > { case_clauses? default_clause? case_clauses? } 
                                                    f:r { { type:env.typ.CaseBlock, nodes:[...$2, $3, ...$4], pos } }

<> case_clauses > case_clause(+)

<> case_clause > t:case expression : statement_list?
                                                    f:r { { type:env.typ.CaseClause, nodes:[$$2, ...$4], pos } }

<> default_clause > t:default : statement_list?
                                                    f:r { { type:env.typ.DefaultClause, nodes:[...$3], pos } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-labeled-statements
###############################################################################################################

<> labeled_statement > label_identifier : labeled_item                                                    
                                                    f:r { { type:env.typ.LabeledStatement, nodes:[$$1, $$3], pos } }

<> labeled_item > statement
    | function_declaration

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-try-statement
###############################################################################################################

<> try_statement > t:try block catch
                                                    f:r { { type:env.typ.TryStatement, nodes:[$$2,$$3,null], pos } }
    | t:try block finally
                                                    f:r { { type:env.typ.TryStatement, nodes:[$$2,null,$$3], pos } }
    | t:try block catch  finally
                                                    f:r { { type:env.typ.TryStatement, nodes:[$$2,$$3,$$4], pos } }

<> catch > t:catch \( catch_parameter \) block
                                                    f:r { { type:env.typ.CatchClause, nodes:[$$3, $$5], pos } }

<> finally > t:finally block
                                                    f:r { { type:env.typ.FinallyClause, nodes:[$$2], pos } }

<> catch_parameter > binding_identifier 
    | binding_pattern

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-debugger-statement
###############################################################################################################

<> debugger_statement > t:debugger asi                                                                         
                                                    f:r { { type:env.typ.DebuggerStatement, pos } }

###############################################################################################################
###############################################################################################################
## DECLARATIONS
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-variable-statement
###############################################################################################################

<> variable_statement > t:var variable_declaration_list asi
                                                    f:r { { type:env.typ.VariableStatement, nodes:$2, pos } }

<> variable_declaration_list > variable_declaration(+\, )                                                         

<> variable_declaration > binding_identifier initializer
                                                    f:r=>BindingExpression
    | binding_identifier                                        
    | binding_pattern initializer
                                                    f:r => BindingExpression


###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-let-and-const-declarations
###############################################################################################################

<> lexical_declaration > ( t:let | t:const ) binding_list asi
                                                    f:r { { type:env.typ.LexicalDeclaration, symbol:$1, nodes:$2, pos } }

<> binding_list > lexical_binding(+\, )                                                                            

<> lexical_binding > binding_identifier

    | binding_identifier initializer
                                                    f:r => BindingExpression
    | binding_pattern initializer
                                                    f:r => BindingExpression

###############################################################################################################
###############################################################################################################
## FUNCTIONS
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-function-definitions
###############################################################################################################

## Modified to include async and function generator elements

<> function_declaration > ! t:async? t:function \* ? binding_identifier 
                        \( formal_parameters? \) { function_body? }
                                                    f:r { { type:env.typ.FunctionDeclaration, ASYNC:!!$$1, GENERATOR:!!$$3, nodes:[$$4,$$6,$$9], pos } }

<> function_expression > t:async? t:function \* ? binding_identifier? 
                        \( formal_parameters? \) { function_body? }
                                                    f:r { { type:env.typ.FunctionExpression, ASYNC:!!$$1, GENERATOR:!!$$3, nodes:[$$4,$$6,$$9], pos } }


<> unique_formal_parameters > formal_parameters

<> formal_parameters > function_rest_parameter
                                                    f:r { { type:env.typ.FormalParameters, nodes:[$1], pos } }
    | formal_parameter_list ,?
                                                    f:r { { type:env.typ.FormalParameters, nodes:$1, pos } }
    | formal_parameter_list , function_rest_parameter
                                                    f:r { { type:env.typ.FormalParameters, nodes:[...$1,$$3], pos } }

<> formal_parameter_list > formal_parameter(+\, )

<> function_rest_parameter > binding_rest_element           

<> formal_parameter > binding_element

<> function_body > function_statement_list
                                                    f:r { { type:env.typ.FunctionBody, nodes:$1 || [], pos } }

<> function_statement_list > statement_list?

###############################################################################################################
# https://262.ecma-international.org/12.0/#prod-GeneratorExpression
###############################################################################################################

<> yield_expression > t:yield g:nl
                                                    f:r { { type: env.typ.YieldExpression, nodes:[], pos } }
    | t:yield ( \* )? assignment_expression
                                                    f:r { { type: env.typ.YieldExpression, nodes:[$$3], pos, GENERATOR:!!$$2 } }


###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-arrow-function-definitions
###############################################################################################################

<> arrow_function > t:async? arrow_parameters \=> concise_body
                                                    f:r { { type:env.typ.ArrowFunction, ASYNC:!!$$1, nodes:[$$2,$$4], pos } }

<> arrow_parameters > identifier_reference
                                                    f:r { $1.type = env.typ.IdentifierBinding, $1 }    
    | cover_parenthesized_expression_and_arrow_parameter_list
                                                    f:r ^reinterpretArrowParameters

<> concise_body > (EXC \{ ) assignment_expression 
    | ! { function_statement_list? }
                                                    f:r { { type: env.typ.BlockStatement, nodes: $2 || [], pos } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-async-arrow-function-definitions
###############################################################################################################

<> cover_call_expression_and_async_arrow_head > member_expression arguments                                 
                                                    f:r { { type: env.typ.CallExpression, nodes:[$1, $2], pos } }

###############################################################################################################
###############################################################################################################
## CLASSES
############################################################################################################### 
###############################################################################################################

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-class-definitions
###############################################################################################################

<> class_declaration > ! t:class binding_identifier class_heritage? { class_body? }                           
                                                    f:r { { type:env.typ.Class, nodes:[$$2, $$3, ...$5], pos } }

<> class_expression > t:class binding_identifier? class_heritage? { class_body? }                            
                                                    f:r { { type:env.typ.Class, nodes:[$$2, $$3, ...$5], pos } }

<> class_heritage > t:extends left_hand_side_expression                          

<> class_body >
        
        class_body class_element
                                                    f:r { $1.concat($2) } 
    |   class_body ;
                                                    f:r { $1 } 
    |   class_element
                                                    f:r { [$1 ] } 
    |   ;
                                                    f:r { [] }

<> class_element > 

     t:static? method_definition
                                                    f:r { ( $2.STATIC = !!$1, $2) }

    | t:static? ( \# (EXC g:sp) property_name | property_name ) initializer? asi       
                                                    f:r { ( $2.STATIC = !!$1, $2) }
    | t:static \{ statement_list \}

    


###############################################################################################################
# https://262.ecma-international.org/12.0/#prod-MethodDefinition
###############################################################################################################

<> method_definition > \async ? \* ? property_name \( unique_formal_parameters? \) { function_body? }      
                                                    f:r { { type:env.typ.Method, ASYNC:!!$$1, GENERATOR:!!$$2, nodes:[$$3, $$5, $$8], pos } } 

    | \get property_name \( \) { function_body? }                                                           
                                                    f:r { { type:env.typ.GetterMethod, nodes:[$$2, $6], pos } }

    | \set property_name \( property_set_parameter_list \) { function_body? }                               
                                                    f:r { { type:env.typ.SetterMethod, nodes:[$$2, $$4, $7], pos } }

<> property_set_parameter_list > formal_parameter 

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-comma-operator
###############################################################################################################

<> expression > expression , assignment_expression
                                                    f:r { ( $1.type == env.typ.ExpressionList ? ( $1.nodes.push($3) , $1 )
                                                                                                        : { type: env.typ.ExpressionList, nodes: [$1, $3], pos } ) }
    | assignment_expression                                                                                 
            
###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-left-hand-side-expressions
###############################################################################################################

<> left_hand_side_expression > new_expression       
    | call_expression         
    | optional_expression                      

<> new_expression > member_expression 

    # | t:new new_expression
    #                                                f:r { { type: env.typ.NewExpression, nodes:[$$2], pos } }

<> member_expression > primary_expression  

    | member_expression \[ expression \]
                                                    f:r { { type: env.typ.MemberExpression, nodes:[$$1, $$3], pos, COMPUTED:true } }
    | member_expression . identifier_name
                                                    f:r { ($3.type |= env.cls.PROPERTY_NAME, { type: env.typ.MemberExpression, nodes:[$$1, $$3], pos, COMPUTED:false }) }
    | member_expression template_literal
                                                    f:r { { type: env.typ.CallExpression, nodes:[$$1, $$2], pos, TEMPLATE:true } }
    | super_property

    | meta_property

    | t:new member_expression arguments
                                                    f:r { { type: env.typ.NewInstanceExpression, nodes:[$$2, $$3], pos } }
    | t:new member_expression
                                                    f:r { { type: env.typ.NewExpression, nodes:[$$2], pos } }

<> super_property > t:super . identifier_name
                                                    f:r { ($3.type |= env.cls.PROPERTY_NAME,{ type: env.typ.SuperExpression, nodes:[$$3], pos, COMPUTED:false } ) }
    | t:super \[ expression \]
                                                    f:r { { type: env.typ.SuperExpression, nodes:[$$3], pos, COMPUTED:true } }

<> meta_property > new_target
    | import_meta

##
# 2020 https://262.ecma-international.org/12.0/#prod-ImportMeta
##
<> import_meta > t:import . t:meta
                                                    f:r { { type: env.typ.ImportMeta, pos } }

<> new_target > t:new . t:target
                                                    f:r { { type: env.typ.NewTarget, pos } }

<> call_expression > call_expression . identifier_name
                                                    f:r { ($3.type |= env.cls.PROPERTY_NAME,{ type: env.typ.MemberExpression, nodes:[$$1, $$3], pos, COMPUTED:false } )}
    | super_call
    | import_call
    | call_expression arguments
                                                    f:r { { type: env.typ.CallExpression, nodes:[$$1, $$2], pos, TEMPLATE:false } }
    | call_expression \[ expression \]
                                                    f:r { { type: env.typ.MemberExpression, nodes:[$$1, $$3], pos, COMPUTED:true } }
    | cover_call_expression_and_async_arrow_head                                                            
    | call_expression template_literal
                                                    f:r { { type: env.typ.CallExpression, nodes:[$$1, $$3], pos, TEMPLATE:true } }

<> super_call > t:super arguments
                                                    f:r { { type: env.typ.SuperCall, nodes:[$$2], pos } }

##
# 2020 https://262.ecma-international.org/12.0/#prod-ImportCall
##
<> import_call > t:import \( assignment_expression \)
                                                    f:r { { type: env.typ.ImportCall, nodes:[$$3], pos } }

<> arguments >  \( argument_list? ,? \)
                                                    f:r { { type: env.typ.Arguments, nodes:$$2 || [], pos } }

<> argument_list > (assignment_expression | \... assignment_expression f:r=>Spread  )(+\, )

###############################################################################################################
# 2020 https://262.ecma-international.org/12.0/#prod-OptionalExpression
###############################################################################################################
                        
<> optional_expression > member_expression optional_chain
                                                    f:r { { type: env.typ.OptionalMemberExpression, nodes:[$$1, $$2.type == "computed" ? $$2.val : $$2], pos, COMPUTED:$$2.type == "computed" } }
    | call_expression optional_chain
                                                    f:r { { type: env.typ.OptionalMemberExpression, nodes:[$$1, $$2.type == "computed" ? $$2.val : $$2], pos, COMPUTED:$$2.type == "computed" } }
    | optional_expression optional_chain
                                                    f:r { { type: env.typ.OptionalMemberExpression, nodes:[$$1, $$2.type == "computed" ? $$2.val : $$2], pos, COMPUTED:$$2.type == "computed" } }

<> optional_chain > \?. arguments    
                                                                       
    | \?. \[ expression \]  
                                                    f:r { { type:"computed", val:$3 } } 
    | \?. identifier_name  

    | \?. template_literal

    | optional_chain arguments
                                                    f:r { { type: env.typ.CallExpression, nodes:[$$1, $$2], pos, TEMPLATE:false } }
    | optional_chain \[ expression \]
                                                    f:r { { type: env.typ.MemberExpression, nodes:[$$1, $$3], pos, COMPUTED:true } }
    | optional_chain \. identifier_name
                                                    f:r { ( $3.type |= env.cls.PROPERTY_NAME, { type: env.typ.MemberExpression, nodes:[$$1, $$3], pos, COMPUTED:false } ) }
    | optional_chain template_literal
                                                    f:r { { type: env.typ.CallExpression, nodes:[$$1, $$2], pos, TEMPLATE:true } }




###############################################################################################################
#https://262.ecma-international.org/12.0/#sec-primary-expression
###############################################################################################################

<> primary_expression > t:this
                                                    f:r { { type: env.typ.ThisLiteral, pos } }
    | identifier_reference
    | literal
    | array_literal                                             
    | object_literal                                            
    | function_expression
    | class_expression
    | regular_expression_literal
    | template_literal
    | parenthesized
                                                    f:r ^reinterpretParenthesized

#| generator_expression
#| async_function_expression
#| async_generator_expression

###############################################################################################################
# https://262.ecma-international.org/12.0/#prod-AwaitExpression
###############################################################################################################

<> await_expression > t:await unary_expression
                                                    f:r { { type: env.typ.AwaitExpression, nodes:[$$2], pos } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#prod-BindingExpression
###############################################################################################################

<> assignment_expression > conditional_expression 

    | yield_expression

    | arrow_function

    | left_hand_side_expression = assignment_expression
                                                    f:r { { type: env.typ.AssignmentExpression, symbol:"=",  nodes:[$1,$3], pos } }

    | left_hand_side_expression assignment_operator assignment_expression
                                                    f:r { { type: env.typ.AssignmentExpression, symbol:$2,  nodes:[$1,$3], pos } }

<> assignment_operator > \*=                                                        
    | \/=
    | \%=
    | \+=
    | \-=
    | \<<=
    | \>>=
    | \>>>=
    | \&=
    | \^=
    | \|=
    | \**=
    | \??=
    | \&&=
    | \||=

###############################################################################################################
# https://262.ecma-international.org/12.0/#prod-ConditionalExpression
###############################################################################################################

<> conditional_expression > short_circuit_expression
    | short_circuit_expression \? assignment_expression : assignment_expression
                                                    f:r { { type: env.typ.ConditionalExpression, nodes:[$$1, $$3, $$5], pos } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-binary-logical-operators
###############################################################################################################

<> short_circuit_expression > logical_or_expression

    | coalesce_expression


<> logical_or_expression > logical_and_expression 

    | logical_or_expression \|| logical_and_expression
                                                    f:r { { type: env.typ.LogicalExpression, symbol:$$2, nodes:[$$1, $$3], pos } }

<> logical_and_expression > bitwise_or_expression 

    | logical_and_expression \&& bitwise_or_expression
                                                    f:r { { type: env.typ.LogicalExpression, symbol:$$2, nodes:[$$1, $$3], pos } }

##
# 2020 https://262.ecma-international.org/12.0/#prod-CoalesceExpression
##

<> coalesce_expression >  bitwise_or_expression \?? bitwise_or_expression
                                                    f:r { { type: env.typ.CoalesceExpression, nodes:[$$1, $$3], pos } }
    | coalesce_expression \?? bitwise_or_expression
                                                    f:r { { type: env.typ.CoalesceExpression, nodes:[$$1, $$3], pos } }


###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-binary-bitwise-operators
###############################################################################################################

<> bitwise_or_expression > bitwise_xor_expression 

    | bitwise_or_expression \| bitwise_xor_expression
                                                    f:r { { type: env.typ.BitwiseExpression, symbol:$$2, nodes:[$$1, $$3], pos } }

<> bitwise_xor_expression > bitwise_and_expression 

    | bitwise_xor_expression ^ bitwise_and_expression
                                                    f:r { { type: env.typ.BitwiseExpression, symbol:$$2, nodes:[$$1, $$3], pos } }

<> bitwise_and_expression > equality_expression 

    | bitwise_and_expression & equality_expression
                                                    f:r { { type: env.typ.BitwiseExpression, symbol:$$2, nodes:[$$1, $$3], pos } }

<> equality_expression > relational_expression 

    | equality_expression \== relational_expression
                                                    f:r { { type: env.typ.EqualityExpression, symbol:$$2, nodes:[$$1, $$3], pos } }
    | equality_expression \!= relational_expression
                                                    f:r { { type: env.typ.EqualityExpression, symbol:$$2, nodes:[$$1, $$3], pos } }
    | equality_expression \=== relational_expression
                                                    f:r { { type: env.typ.EqualityExpression, symbol:$$2, nodes:[$$1, $$3], pos } }
    | equality_expression \!== relational_expression
                                                    f:r { { type: env.typ.EqualityExpression, symbol:$$2, nodes:[$$1, $$3], pos } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-relational-operators
###############################################################################################################

<> relational_expression > shift_expression 

    | relational_expression < shift_expression
                                                    f:r { { type: env.typ.RelationalExpression, symbol:$$2, nodes:[$$1, $$3], pos } }
    | relational_expression \>  shift_expression
                                                    f:r { { type: env.typ.RelationalExpression, symbol:$$2, nodes:[$$1, $$3], pos } }
    | relational_expression \<= shift_expression
                                                    f:r { { type: env.typ.RelationalExpression, symbol:$$2, nodes:[$$1, $$3], pos } }
    | relational_expression \>= shift_expression
                                                    f:r { { type: env.typ.RelationalExpression, symbol:$$2, nodes:[$$1, $$3], pos } }
    | relational_expression t:instanceof shift_expression
                                                    f:r { { type: env.typ.InstanceOfExpression,  nodes:[$$1, $$3], pos } }
    | relational_expression t:in shift_expression
                                                    f:r { { type: env.typ.InExpression,  nodes:[$$1, $$3], pos } }   

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-bitwise-shift-operators
###############################################################################################################

<> shift_expression > additive_expression 

    | shift_expression \<< additive_expression
                                                    f:r { { type: env.typ.ShiftExpression, symbol:$$2, nodes:[$$1, $$3], pos } }
    | shift_expression \>> additive_expression
                                                    f:r { { type: env.typ.ShiftExpression, symbol:$$2, nodes:[$$1, $$3], pos } }
    | shift_expression \>>> additive_expression
                                                    f:r { { type: env.typ.ShiftExpression, symbol:$$2, nodes:[$$1, $$3], pos } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-additive-operators
###############################################################################################################

<> additive_expression > multiplicative_expression 

    | additive_expression + multiplicative_expression
                                                    f:r { { type: env.typ.AdditiveExpression, symbol:$$2, nodes:[$$1, $$3], pos } }
    | additive_expression - multiplicative_expression
                                                    f:r { { type: env.typ.AdditiveExpression, symbol:$$2, nodes:[$$1, $$3], pos } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-multiplicative-operators
###############################################################################################################

<> multiplicative_expression > exponentiation_expression 

    | multiplicative_expression * exponentiation_expression
                                                    f:r { { type: env.typ.MultiplicativeExpression, symbol:$$2, nodes:[$$1, $$3], pos } }
    | multiplicative_expression / exponentiation_expression
                                                    f:r { { type: env.typ.MultiplicativeExpression, symbol:$$2, nodes:[$$1, $$3], pos } }
    | multiplicative_expression % exponentiation_expression
                                                    f:r { { type: env.typ.MultiplicativeExpression, symbol:$$2, nodes:[$$1, $$3], pos } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-exp-operator
###############################################################################################################

<> exponentiation_expression > unary_expression 

    | update_expression \** exponentiation_expression
                                                    f:r { { type: env.typ.ExponentiationExpression, nodes:[$$1, $$3], pos } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-unary-operators
###############################################################################################################

<> unary_expression > update_expression 

    | t:delete unary_expression
                                                    f:r { { type: env.typ.DeleteExpression, nodes:[$$2], pos } }
    | t:void unary_expression
                                                    f:r { { type: env.typ.VoidExpression, nodes:[$$2], pos } }
    | t:typeof unary_expression
                                                    f:r { { type: env.typ.TypeofExpression, nodes:[$$2], pos } }
    | + unary_expression
                                                    f:r { { type: env.typ.UnaryExpression, symbol:$1, nodes:[$$2], pos } }
    | ~ unary_expression
                                                    f:r { { type: env.typ.UnaryExpression, symbol:$1, nodes:[$$2], pos } }
    | \! unary_expression
                                                    f:r { { type: env.typ.UnaryExpression, symbol:$1, nodes:[$$2], pos } }
    | - unary_expression                                                                                    
                                                    f:r { 
                                                        ($$2.type == env.typ.NumericLiteral || $$2.type == env.typ.BigIntLiteral)
                                                        ? ($$2.NEGATIVE = true, $$2)
                                                        : ({ type: env.typ.UnaryExpression, symbol:$1, nodes:[$$2], pos }) 
                                                    }
    | await_expression

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-update-expressions
###############################################################################################################

<> update_expression >  left_hand_side_expression 

    | left_hand_side_expression  \++
                                                    f:r { { type: env.typ.PostExpression, symbol:$$2, nodes:[$$1], pos } }
    | left_hand_side_expression  \--
                                                    f:r { { type: env.typ.PostExpression, symbol:$$2, nodes:[$$1], pos } }
    | \++ unary_expression
                                                    f:r { { type: env.typ.PreExpression, symbol:$$1, nodes:[$$2], pos } }
    | \-- unary_expression
                                                    f:r { { type: env.typ.PreExpression, symbol:$$1, nodes:[$$2], pos } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#prod-CoverParenthesizedExpressionAndArrowParameterList
###############################################################################################################

<> cover_parenthesized_expression_and_arrow_parameter_list > \( \)
                                                    f:r { { type: env.typ.Parenthesized, nodes:[], pos } }
    | \( expression , \)
                                                    f:r { { type: env.typ.Parenthesized, nodes:[$$2], pos } }
    | \( ( \... binding_identifier f:r=>Spread)  \)
                                                    f:r { { type: env.typ.Parenthesized, nodes:[$$2], pos } }
    | \( ( \... binding_pattern f:r=>Spread) \)
                                                    f:r { { type: env.typ.Parenthesized, nodes:[$$2], pos } }
    | \( expression , ( \... binding_identifier f:r=>Spread)  \)
                                                    f:r { { type: env.typ.Parenthesized, nodes:[$$2, $$4], pos } }
    | \( expression , ( \... binding_pattern f:r=>Spread)  \)
                                                    f:r { { type: env.typ.Parenthesized, nodes:[$$2, $$4], pos } }                                                                                       
    | parenthesized                                                                                         

<> parenthesized > \( expression \)
                                                    f:r { { type: env.typ.Parenthesized, nodes:[$$2], pos } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#prod-BindingPattern
###############################################################################################################

<> binding_pattern > object_binding_pattern
    |   array_binding_pattern

<> object_binding_pattern > { }
                                                    f:r { { type: env.typ.ObjectBinding, nodes:[], pos } }
    | { binding_rest_property }
                                                    f:r { { type: env.typ.ObjectBinding, nodes:[$2], pos } }
    | { binding_property_list  }
                                                    f:r { { type: env.typ.ObjectBinding, nodes:[...$2], pos } }    
    | { binding_property_list , binding_rest_property? }
                                                    f:r { { type: env.typ.ObjectBinding, nodes:[...$2, $4], pos } }    

<> array_binding_pattern >  \[ elision? binding_rest_element? \]
                                                    f:r { { type: env.typ.ArrayBinding, nodes:[$2, $3], pos } }
    | \[ binding_element_list \]
                                                    f:r { { type: env.typ.ArrayBinding, nodes:[...$2], pos } }    
    | \[ binding_element_list \, elision? binding_rest_element? \]
                                                    f:r { { type: env.typ.ArrayBinding, nodes:[...$2, $4, $5], pos } }    

<> binding_property_list > binding_property
                                                    f:r { [$$1] }
    | binding_property_list \, binding_property
                                                    f:r { [...$$1, $3] }

<> binding_element_list > binding_elision_element                                                           
    | binding_element_list \, binding_elision_element
                                                    f:r { [...$$1, ...$3] }

<> binding_elision_element > elision? binding_element
                                                    f:r { [$1, $2] }                                                    

<> binding_property > single_name_binding 
    | property_name : binding_element
                                                    f:r { { type:env.typ.PropertyBinding, nodes:[$1, $3],  pos  } }  

<> binding_element > single_name_binding
    | binding_pattern initializer?
                                                    f:r { $$2 ? { type:env.typ.BindingExpression, symbol:"=",  nodes: [$1, $2],  pos  } : $1 }

<> single_name_binding > binding_identifier initializer?
                                                    f:r { $$2 ? { type:env.typ.BindingExpression, symbol:"=",  nodes: [$1, $2],  pos  } : $1 }

<> binding_rest_property > \... binding_identifier
                                                    f:r=>Spread
<> binding_rest_element > \... binding_identifier
                                                    f:r=>Spread
    | \... binding_pattern
                                                    f:r=>Spread                                                                                              


###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-object-initializer
###############################################################################################################

<> object_literal >  { }
                                                    f:r { { type:env.typ.ObjectLiteral, nodes:[],  pos  } }
    | { property_definition_list ,? }
                                                    f:r { { type:env.typ.ObjectLiteral, nodes:$2,  pos  } }

<> property_definition_list > property_definition
                                                    f:r { [$1] }
    | property_definition_list , property_definition
                                                    f:r { $1.push($3), $1 }       

<> property_definition >  cover_initialized_name                
    | identifier_property_name
                                                    f:r { $1.type |= env.cls.PROPERTY_NAME, $1 }
    | method_definition                                                                                     
    | \... assignment_expression                                                                   f:r =>Spread
    | property_name : assignment_expression
                                                    f:r { { type:env.typ.PropertyBinding, nodes:[$1, $3],  pos  } }       

<> property_name > literal_property_name
                                                    f:r { $1.type |= env.cls.PROPERTY_NAME, $1 }
    | computed_property_name
                                                    f:r { $1.type |= env.cls.PROPERTY_NAME, $1 }

<> literal_property_name > identifier_property_name                                                                  
    | string_literal
    | numeric_literal

<> computed_property_name > \[ assignment_expression \]
                                                    f:r { { type: env.typ.ComputedProperty, nodes:[$2], pos } }

<> cover_initialized_name > identifier_property_name initializer
                                                    f:r { 
                                                            $1.type |= env.cls.PROPERTY_NAME, 
                                                            { type:env.typ.BindingExpression, symbol:"=",  nodes: [$1, $2],  pos  }
                                                    }

<> initializer > = assignment_expression
                                                    f:r { $2 }


###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-array-initializer
###############################################################################################################

<> array_literal > \[ elision? \]
                                                    f:r { { type: env.typ.ArrayLiteral, nodes:[$2], pos } }
    | \[ element_list \]
                                                    f:r { { type: env.typ.ArrayLiteral, nodes:$$2, pos } }
    | \[ element_list , elision? \]
                                                    f:r { { type: env.typ.ArrayLiteral, nodes:[...$$2, $4], pos } }

<> element_list > elision? assignment_expression
                                                    f:r { [$1, $2 ] }
    | elision? spread_element
                                                    f:r { [ $1,$2 ] }
    | element_list , elision? assignment_expression
                                                    f:r { [ ...$1, $3, $4 ] }
    | element_list , elision? spread_element
                                                    f:r { [ ...$1, $3, $4 ] }

<> elision > ,
                                                    f:r { { type: env.typ.Elision, count:0, pos } }
    | elision ,
                                                    f:r { { type: env.typ.Elision, count:$1.count+1, pos } }

<> spread_element > \... assignment_expression      
                                                    f:r=>Spread

###############################################################################################################
#https://262.ecma-international.org/12.0/#prod-TemplateLiteral
###############################################################################################################

<> template_literal > no_substitute_template
    | substitute_template 

<> no_substitute_template > \` tk:template_string? \`                                            
                                                    f:r { { type: env.typ.Template, nodes:[ { quote_type:"", type: env.typ.StringLiteral, value:$2,  pos  }], NO_SUBSTITUTE:true, pos } }

<> substitute_template > template_head expression template_spans                                            
                                                    f:r { $3.unshift($1, $2), { type: env.typ.Template, nodes:$$3, pos } }

<> template_spans > template_tail                                                                           
                                                    f:r { [ $1 ] }
    | template_middle_list template_tail                                                                    
                                                    f:r { $1.push($2), $1 }           

<> template_middle_list > template_middle expression                                                        
                                                    f:r { [ $1, $2 ] }
    | template_middle_list template_middle expression                                                       
                                                    f:r { $1.push($2, $3), $1 }

<> template_head >       \` tk:template_string? \${                                                             
                                                    f:r { { type:env.typ.TemplateHead, value:$2 || "", pos  } }

<> template_middle >    \} tk:template_string? \${                                                             
                                                    f:r { { type:env.typ.TemplateMiddle, value:$2 || "",  pos  } }

<> template_tail >      \} tk:template_string? \`                                                               
                                                    f:r { { type:env.typ.TemplateTail, value:$2 || "",  pos  } }

<> template_string > template_string_data(+\" ) (  ?=\` | ?=\${  ) 

<> template_string_data >  g:nl | g:sp | g:sym | g:num | g:id | template_escaped_sequence  


<> template_escaped_sequence > \\ ( g:sp | g:sym | g:num | g:id ) f:r { $1 + $2}

###############################################################################################################
# https://262.ecma-international.org/12.0/#prod-RegularExpressionLiteral
###############################################################################################################

<> regular_expression_literal > \/ (g:nl | g:sp | g:sym | g:num | g:id | escaped_sequence | \\/ )(*\" ) \/ def::js_identifier?
                                                    f:r { { type:env.typ.RegexLiteral, value:$2, flags:$4,  pos  } }

<> regular_expression_flags > identifier_name  

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-ecmascript-language-lexical-grammar
###############################################################################################################

<> literal > boolean_literal                
    | null_literal
    | string_literal                    
    | numeric_literal    

<> string_literal > 

        \" (RST g:sp g:nl tk:comment) tk:double_quote_string_data? \"
                                                    f:r { { quote_type:$1, type: env.typ.StringLiteral, value:$$2 || "",  pos  } }

    |   \' (RST g:sp g:nl tk:comment) tk:single_quote_string_data? \'
                                                    f:r { { quote_type:$1, type: env.typ.StringLiteral, value:$$2 || "",  pos  } }

<> single_quote_string_data > ( \" | g:nl | g:sp | g:sym | g:num | g:id | escaped_sequence )(*\" ) ?=\' 

<> double_quote_string_data > ( \' | g:nl | g:sp | g:sym | g:num | g:id | escaped_sequence )(*\" ) ?=\"
                   

<> escaped_sequence > \\ ( g:nl | g:sp | g:sym | g:num | g:id  )
                                                    f:r { $1 + $2}

<> numeric_literal > scientific_token
                                                    f:r { { type: env.typ.NumericLiteral, value:$1, computed_value:parseFloat($1.replace(/_/g,"")), pos, NEGATIVE:false } }
    | big_token
                                                    f:r { { type: env.typ.BigIntLiteral, value:$1, computed_value:parseFloat($1.replace(/_/g,"")), pos, NEGATIVE:false } }
    | hex_token
                                                    f:r { { type: env.typ.NumericLiteral, value:$1, computed_value:parseFloat($1.replace(/_/g,"")), pos, NEGATIVE:false } }
    | octal_token
                                                    f:r { { type: env.typ.NumericLiteral, value:$1, computed_value:parseFloat($1.replace(/_/g,"")), pos, NEGATIVE:false } }
    | binary_token
                                                    f:r { { type: env.typ.NumericLiteral, value:$1, computed_value:parseFloat($1.replace(/_/g,"")), pos, NEGATIVE:false } }


<> big_token >  int_token (RST g:sp g:nl) t:n                                                                                
                                                    f:r { $1 }
                                                                                                      
<> scientific_token > float_token ( (\e | \E ) \- ? int_token f:r { $1 + $2 + $3} )?                        
                                                    f:r {$1+$2}

<> float_token > int_token ( \. int_token f:r { $1 + $2} )?                                                 
                                                    f:r { $1 + $2}

<> int_token > g:num ( \_  g:num f:r { $1 + $2}  )(*\" )                                                    
                                                    f:r { $1 + $2}                                                                

<> hex_token > ( \0x | \0X ) ( g:num | \a | \b | \c | \d | \e | \f | \A | \B | \C | \D | \E | \F )(+\" ) 
                                ( \_ ( g:num | \a | \b | \c | \d | \e | \f | \A | \B | \C | \D | \E | \F )(+\" ) f:r {$1+$2} )(*\" )

                                                    f:r { $1 + $2 + $3}   

<> binary_token > ( \0b | \0B ) ( \0 | \1 )(+\" ) ( \_ ( \0 | \1 )(+\" ) f:r {$1+$2} )(*\" )                            
                                                    f:r { $1 + $2 + $3}   

<> octal_token > ( \0o | \0O ) ( \0 | \1 | \2 | \3 | \4 | \5 | \6 | \7 )(+\" ) ( \_ ( \0 | \1 | \2 | \3 | \4 | \5 | \6 | \7 )(+\" ) f:r {$1+$2} )(*\" )
                                                    f:r { $1 + $2 + $3}   

<> null_literal >  t:null
                                                    f:r { { type: env.typ.NullLiteral, pos  } }

<> boolean_literal > t:true
                                                    f:r { { type: env.typ.BooleanLiteral, value: $$1,  pos  } }
    | t:false
                                                    f:r { { type: env.typ.BooleanLiteral, value: $$1,  pos  } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-names-and-keywords
###############################################################################################################

<> label_identifier > tk:composite_identifier
                                                    f:r { {type: env.typ.IdentifierLabel, value:$1 } }

<> goto_label_identifier > label_identifier
                                                    f:r { {type: env.typ.IdentifierLabel, value:$1 } }

<> identifier_reference > tk:composite_identifier
                                                    f:r { {type: env.typ.IdentifierReference, value:$1 } }

<> binding_identifier > tk:composite_identifier
                                                    f:r { {type: env.typ.IdentifierBinding, value:$1 } }

<> identifier >  tk:composite_identifier
                                                    f:r { { type: env.typ.Identifier, value:$1,  pos  } }   

<> identifier_property_name > tk:composite_identifier 
                                                    f:r { { type: env.typ.IdentifierName, value:$1,  pos  } }         

<> identifier_name > tk:composite_identifier 
                                                    f:r { { type: env.typ.IdentifierName, value:$1,  pos  } }                                     
                                                                                                          
<> composite_identifier > composite_identifier (RST g:sp g:nl) g:id
    | composite_identifier (RST g:sp g:nl) \_
    | composite_identifier (RST g:sp g:nl) \$
    | composite_identifier (RST g:sp g:nl) g:num
    | \_ 
    | \$ 
    | g:id

# Keywords are implied when the t: operator is used to define a 
# terminal.
