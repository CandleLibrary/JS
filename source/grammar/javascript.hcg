@NAME ECMAScriptParser

@EXT js

@SYMBOL  ... < > <= >= == != === !== ** ++ -- << >> >>> && || += -= *= %= /= **= <<= >>= >>>= &= |= ^= => // /* ${

@IGNORE θws θnl

@ERROR /* //

@IMPORT ../../node_modules/@candlefw/hydrocarbon/source/grammars/misc/default-productions.hcg as def 

###############################################################################################################
#### Repeated Functions
###############################################################################################################

↦BindingExpression{ { type:env.typ.BindingExpression, symbol:"=", nodes: [$sym1, $sym2],  pos  } }

↦Spread{ { type:env.typ.Spread, nodes: [$sym2],  pos  } }


###############################################################################################################
###############################################################################################################
###############################################################################################################
# Productions
###############################################################################################################
###############################################################################################################
###############################################################################################################

<> javascript → start                                                                                           ↦r { env.IS_MODULE = false, $sym1 }

<> start → module                                                                                               ↦r { { type:(env.IS_MODULE) ? env.typ.Module : env.typ.Script, nodes:$sym1, pos  } }

###############################################################################################################
###############################################################################################################
## MODULES
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-language-scripts-and-modules
###############################################################################################################

    <> module → module_body      

    <> module_body → module_item(+)                                                                         

    <> module_item → import_declaration                                                                         ↦ { env.IS_MODULE = true }
        │ export_declaration                                                                                    ↦ { env.IS_MODULE = true }
        │ statement_list_item

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#prod-ImportDeclaration
###############################################################################################################

    <> import_declaration → τimport import_clause from_clause ;                                                 ↦r { { type:env.typ.ImportDeclaration, nodes:[$sym2, $sym3], pos } }
        │ τimport module_specifier ;                                                                            ↦r { { type:env.typ.ImportDeclaration, nodes:[null, $sym2], pos } }

    <> import_clause → imported_default_binding                                                                 ↦r { { type:env.typ.ImportClause, nodes:[$$sym1], pos } }
        │ name_space_import                                                                                     ↦r { { type:env.typ.ImportClause, nodes:[$$sym1], pos } }
        │ named_imports                                                                                         ↦r { { type:env.typ.ImportClause, nodes:[$$sym1], pos } }
        │ imported_default_binding , name_space_import                                                          ↦r { { type:env.typ.ImportClause, nodes:[$$sym1, $$sym3], pos } }
        │ imported_default_binding , named_imports                                                              ↦r { { type:env.typ.ImportClause, nodes:[$$sym1, $$sym3], pos } }

    <> imported_default_binding → imported_binding                                                              ↦r { $sym1.type = env.typ.IdentifierDefault, $sym1 }

    <> name_space_import → * τas imported_binding                                                               ↦r { { type:env.typ.NameSpaceImport, nodes:[$$sym3], pos } }

    <> named_imports → { import_specifier(*,) ,? }                                                              ↦r { { type:env.typ.NamedImports, nodes:$$sym2 || [], pos } }

    <> from_clause → τfrom module_specifier                                                                     ↦r { { type:env.typ.FromClause, nodes:[$sym2], pos } }

    <> import_specifier → imported_binding                                                                      
        │ identifier τas imported_binding                                                                       ↦r { { type:env.typ.Specifier, nodes:[$sym1, $sym3], pos } }

    <> module_specifier → string_literal                                                                        

    <> imported_binding → identifier                                                                            ↦r { $sym1.type = env.typ.IdentifierModule, $sym1 }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-exports
###############################################################################################################

    <> export_declaration → τexport * from_clause ;                                                             ↦r { { type:env.typ.ExportDeclaration, nodes:[null, $sym3], DEFAULT:false, pos } }
        │ τexport export_clause from_clause? ;                                                                  ↦r { { type:env.typ.ExportDeclaration, nodes:[$sym2, $$sym3], DEFAULT:false, pos } }
        │ τexport variable_statement                                                                            ↦r { { type:env.typ.ExportDeclaration, nodes:[$sym2], DEFAULT:false, pos } }
        │ τexport declaration                                                                                   ↦r { { type:env.typ.ExportDeclaration, nodes:[$sym2], DEFAULT:false, pos } }
        │ τexport τdefault hoistable_declaration                                                                ↦r { { type:env.typ.ExportDeclaration, nodes:[$sym3], DEFAULT:true, pos } }
        │ τexport τdefault class_declaration                                                                    ↦r { { type:env.typ.ExportDeclaration, nodes:[$sym3], DEFAULT:true, pos } }
        │ τexport τdefault                                                                                      

            (EXC τfunction )
            (EXC τclass )
            (EXC τasync τfunction )
        
            assignment_expression ;                                                                              ↦r { { type:env.typ.ExportDeclaration, nodes:[$sym3], DEFAULT:true, pos } }

    <> export_clause → { export_specifier(*,) ,? }                                                              ↦r { { type:env.typ.ExportClause, nodes:$$sym2||[], pos } }

    <> export_specifier →  identifier                                                                           
        │ identifier τas identifier                                                                             ↦r { { type:env.typ.Specifier, nodes:[$sym1, $sym3], pos } }

###############################################################################################################
###############################################################################################################
## SCRIPT
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-language-scripts-and-modules
###############################################################################################################

    <> script → script_body                                                                                     ↦r { { type:env.typ.Script, nodes:$sym1, pos } }

    <> script_body → statement_list                                                                            

############################################################################################################### 
###############################################################################################################
## STATEMENTS
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#prod-Statement
###############################################################################################################

    <> statement_list → statement_list_item                                                                     ↦r { [ $sym1 ] }
        │ statement_list statement_list_item                                                                    ↦r { [ ...$sym1, $sym2 ] }                             

    <> statement_list_item → statement 
        │ declaration


    <> statement → block_statement 
        │ 
            (EXC { )
            (EXC τfunction )
            (EXC τclass )
            (EXC τlet \[ )
            (EXC τasync τfunction )

            expression_statement                           

        │ labeled_statement
        │ variable_statement
        │ empty_statement
        │ if_statement
        │ breakable_statement 
        │ continue_statement
        │ break_statement
        │ return_statement
        │ with_statement
        │ throw_statement
        │ try_statement
        │ debugger_statement

    <> declaration → class_declaration
        │ hoistable_declaration
        │ lexical_declaration

    <> hoistable_declaration → function_declaration
        #│ generator_declaration
        #│ async_function_declaration
        #│ async_generator_declaration

    <> breakable_statement → iteration_statement
        │ switch_statement


###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-block
###############################################################################################################

    <> block_statement → block                          

    <> block → { statement_list? }                                                                               ↦r { { type: env.typ.BlockStatement, nodes: $$sym2 || [], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-empty-statement
###############################################################################################################

    <> empty_statement → ;                                                                                      ↦r { { type: env.typ.EmptyStatement, pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-expression-statement
###############################################################################################################

    <> expression_statement → expression ;                                                                      ↦r { { type: env.typ.ExpressionStatement, nodes:[$sym1], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-expression-statement
###############################################################################################################

    <> if_statement → τif \( expression \) statement (τelse statement)?                                         ↦r { { type: env.typ.IfStatement, nodes:[$$sym3, $$sym5, $$sym6], pos } }                

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-iteration-statements
###############################################################################################################

    <> iteration_statement → τdo statement τwhile \( expression \) ;                                            ↦r { { type: env.typ.DoStatement, nodes:[$$sym2, $$sym5], pos } }

        │ τwhile \( expression \) statement                                                                     ↦r { { type: env.typ.WhileStatement, nodes:[$$sym3, $$sym5], pos } }
        
        │ τfor \( ↦{ env.ASI = false; } (
            (EXC τlet \[ ) expression 
            │ τvar variable_declaration_list ↦r { { type:env.typ.VariableDeclaration, nodes:$sym2, pos } }
            )? ; expression? ; expression? \) ↦{ env.ASI = true;} statement                                                 
                                                                                                                ↦r { { type: env.typ.ForStatement, nodes:[$$sym3, $$sym5, $$sym7, $$sym9], LEX:false, pos } }

        │ τfor \( lexical_declaration expression? ; expression? \)↦{ env.ASI = true;} statement                 ↦r { { type: env.typ.ForStatement, nodes:[$$sym3, $$sym4, $$sym6, $$sym8], LEX:true, pos } }                                                                           
                                                                                                                                                                                                                                                                            
        │ τfor \( (
                (EXC τlet \[ ) left_hand_side_expression
                │ τvar for_binding ↦r { { type:env.typ.VariableDeclaration, nodes:[$sym1], pos }  }
                │ for_declaration
            ) τin expression \)↦{ env.ASI = true;} statement                                                    ↦r { { type: env.typ.ForInStatement, nodes:[$$sym3, $$sym5, $$sym7], pos } } 

        │ τfor τawait? \( (
                (EXC τlet \[ ) left_hand_side_expression
                │ τvar for_binding ↦r { { type:env.typ.VariableDeclaration, nodes:[$sym1],lex }  }
                │ for_declaration
            ) τof expression \)↦{ env.ASI = true;} statement                                                    ↦r { { type: env.typ.ForOfStatement, nodes:[$$sym4, $$sym6, $$sym8], pos, AWAIT:!!$$sym2 } }

    <> for_declaration → let_or_const for_binding                                                                ↦r { { type: env.typ.LexicalBinding, nodes:[$$sym2], symbol:$$sym1, pos } }

    <> for_binding → binding_identifier 
        │ binding_pattern 

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-continue-statement
###############################################################################################################

    <> continue_statement → τcontinue label_identifier? ;                                                       ↦r { { type: env.typ.ContinueStatement, nodes:[$$sym2], pos } }  

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-break-statement
###############################################################################################################

    <> break_statement → τbreak label_identifier? ;                                                             ↦r { { type: env.typ.BreakStatement, nodes:[$$sym2], pos } }


###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-return-statement
###############################################################################################################

    <> return_statement → τreturn expression? ;                                                                 ↦r { { type:env.typ.ReturnStatement, nodes:[$sym2], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-throw-statement
###############################################################################################################

    <> throw_statement → τthrow expression ;                                                                    ↦r { { type:env.typ.ThrowStatement, nodes:[$$sym2], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-with-statement
###############################################################################################################

    <> with_statement → τwith \( expression \) statement                                                        ↦r { { type:env.typ.WithStatement, nodes:[$$sym3, $$sym5], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-switch-statement
###############################################################################################################

    <> switch_statement → τswitch \( expression \) case_block                                                   ↦r { { type:env.typ.SwitchStatement, nodes:[$$sym3, $$sym5], pos } }

    <> case_block → { case_clauses? default_clause? case_clauses? }                                             ↦r { { type:env.typ.CaseBlock, nodes:[...$sym2, $sym3, ...$sym4], pos } }

    <> case_clauses → case_clause(+)

    <> case_clause → τcase expression : statement_list?                                                         ↦r { { type:env.typ.CaseClause, nodes:[$$sym2, ...$sym4], pos } }

    <> default_clause → τdefault : statement_list?                                                              ↦r { { type:env.typ.DefaultClause, nodes:[...$sym3], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-labeled-statements
###############################################################################################################

    <> labeled_statement → label_identifier : labeled_item                                                    ↦r { { type:env.typ.LabeledStatement, nodes:[$$sym1, $$sym3], pos } }

    <> labeled_item → statement
        │ function_declaration

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-try-statement
###############################################################################################################

    <> try_statement → τtry block catch                                                                         ↦r { { type:env.typ.TryStatement, nodes:[$$sym2,$$sym3,null], pos } }
        │ τtry block finally                                                                                    ↦r { { type:env.typ.TryStatement, nodes:[$$sym2,null,$$sym3], pos } }
        │ τtry block catch  finally                                                                             ↦r { { type:env.typ.TryStatement, nodes:[$$sym2,$$sym3,$$sym4], pos } }

    <> catch → τcatch \( catch_parameter \) block                                                               ↦r { { type:env.typ.CatchClause, nodes:[$$sym3, $$sym5], pos } }

    <> finally → τfinally block                                                                                 ↦r { { type:env.typ.FinallyClause, nodes:[$$sym2], pos } }

    <> catch_parameter → binding_identifier 
        │ binding_pattern

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-debugger-statement
###############################################################################################################

    <> debugger_statement → τdebugger ;                                                                         ↦r { { type:env.typ.DebuggerStatement, pos } }

###############################################################################################################
###############################################################################################################
## DECLARATIONS
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-variable-statement
###############################################################################################################

    <> variable_statement → τvar variable_declaration_list ;                                                    ↦r { { type:env.typ.VariableStatement, nodes:$sym2, pos } }

    <> variable_declaration_list → variable_declaration(+,)                                                         

    <> variable_declaration → binding_identifier initializer                                                    ↦r=>BindingExpression
        │ binding_identifier                                        
        │ binding_pattern initializer                                                                           ↦r=>BindingExpression


###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-let-and-const-declarations
###############################################################################################################

        <> lexical_declaration → let_or_const binding_list ;                                                    ↦r { { type:env.typ.LexicalDeclaration, symbol:$sym1, nodes:$sym2, pos } }

        <> let_or_const → τlet                                                                                  ↦r { "let" }
            │ τconst                                                                                            ↦r { "const" }

        <> binding_list → lexical_binding(+,)                                                                            

        <> lexical_binding → binding_identifier
            │ binding_identifier initializer                                                                    ↦r=>BindingExpression
            │ binding_pattern initializer                                                                       ↦r=>BindingExpression

###############################################################################################################
###############################################################################################################
## FUNCTIONS
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-function-definitions
###############################################################################################################

    ## Modified to include async and function generator elements

    <> function_declaration →  τasync? τfunction \*? binding_identifier? 
                                \( formal_parameters? \) { function_body? }                                     ↦r { { type:env.typ.FunctionDeclaration, ASYNC:!!$$sym1, GENERATOR:!!$$sym3, nodes:[$$sym4,$$sym6,$$sym9], pos } }

    <> function_expression → τasync? τfunction \*? binding_identifier? 
                                \( formal_parameters? \) { function_body? }                                     ↦r { { type:env.typ.FunctionExpression, ASYNC:!!$$sym1, GENERATOR:!!$$sym3, nodes:[$$sym4,$$sym6,$$sym9], pos } }

    <> unique_formal_parameters → formal_parameters

    <> formal_parameters → function_rest_parameter                                                              ↦r { { type:env.typ.FormalParameters, nodes:[$sym1], pos } }
         │ formal_parameter_list ,?                                                                             ↦r { { type:env.typ.FormalParameters, nodes:$sym1, pos } }
         │ formal_parameter_list , function_rest_parameter                                                      ↦r { $$sym1.push($$sym3), { type:env.typ.FormalParameters, nodes:$sym1, pos } }

    <> formal_parameter_list → formal_parameter(+,)                                                                     

    <> function_rest_parameter → binding_rest_element           

    <> formal_parameter → binding_element

    <> function_body → function_statement_list                                                                  ↦r { { type:env.typ.FunctionBody, nodes:$sym1, pos } }

    <> function_statement_list → statement_list?

###############################################################################################################
#https://www.ecma-international.org/ecma-262/10.0/index.html#prod-GeneratorExpression
###############################################################################################################

    # <> async_function_declaration → τasync τfunction binding_identifier? \( formal_parameters? \) { async_function_body? }     

    # <> async_function_expression → τasync τfunction \( formal_parameters? \) { async_function_body? }                          

    # <> async_function_method → τasync property_name \( unique_formal_parameters? \) { async_function_body? }                   

    # <> async_function_body → function_body

###############################################################################################################
#https://www.ecma-international.org/ecma-262/10.0/index.html#prod-AsyncGeneratorExpression
###############################################################################################################

    # <> async_generator_method → τasync \* property_name \( unique_formal_parameters? \) { async_generator_body? }               

    # <> async_generator_declaration → τasync τfunction \* binding_identifier? \( formal_parameters? \) { async_function_body? }  

    # <> async_generator_expression → τasync τfunction \* \( formal_parameters? \) { async_function_body? }                       

    # <> async_generator_body → function_body

###############################################################################################################
#https://www.ecma-international.org/ecma-262/10.0/index.html#prod-GeneratorExpression
###############################################################################################################

    # <> generator_method → \* property_name  \( unique_formal_parameters? \) { generator_body }                                  

    # <> generator_declaration → τfunction \* binding_identifier \( formal_parameters? \) { generator_body }                       

    # <> generator_expression → τfunction \* \( formal_parameters? \) {generator_body}                                             

    # <> generator_body → function_body

    <> yield_expression → τyield (RED θnl)                                                                      ↦r { { type: env.typ.YieldExpression, nodes:[], pos } }
        │ τyield \*? assignment_expression                                                                      ↦r { { type: env.typ.YieldExpression, nodes:[$$sym3], pos, GENERATOR:!!$$sym2 } }


###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-arrow-function-definitions
###############################################################################################################

    <> arrow_function → τasync? arrow_parameters => concise_body                                                ↦r { { type:env.typ.ArrowFunction, ASYNC:!!$$sym1, nodes:[$$sym2,$$sym4], pos } }

    <> arrow_parameters → binding_identifier                                                                        
        │ cover_parenthesized_expression_and_arrow_parameter_list                                               ↦r ^reinterpretArrowParameters

    <> concise_body → (EXC { ) assignment_expression 
        │ { function_statement_list }                                                                           ↦r { { type: env.typ.BlockStatement, nodes: $sym2, pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-async-arrow-function-definitions
###############################################################################################################

    #    <> async_arrow_function → τasync async_arrow_parameters => async_concise_body                          ↦c ^async_arrow

    #    <> async_arrow_parameters → binding_identifier 
    #        │ cover_call_expression_and_async_arrow_head                                                       

    #    <> async_concise_body → (EXC { ) assignment_expression 
    #        │ { function_statement_list }                                                                      ↦r { $sym2 }

    <> cover_call_expression_and_async_arrow_head → member_expression arguments                                 ↦r { { type: env.typ.CallExpression, nodes:[$sym1, $sym2], pos } }

###############################################################################################################
###############################################################################################################
## CLASSES
############################################################################################################### 
###############################################################################################################

###############################################################################################################
# https://www.ecma-international.org/ecma-262/index.html#sec-class-definitions
###############################################################################################################

    <> class_declaration → τclass binding_identifier? class_heritage? { class_body? }                           ↦r { { type:env.typ.Class, nodes:[$$sym2, $$sym3, ...$sym5], pos } }

    <> class_expression → τclass binding_identifier? class_heritage? { class_body? }                            ↦r { { type:env.typ.Class, nodes:[$$sym2, $$sym3, ...$sym5], pos } }

    <> class_heritage → τextends left_hand_side_expression                          

    <> class_body → class_element(+)

    <> class_element → method_definition 
        │ τstatic method_definition                                                                             ↦r { ( $sym2.STATIC = true, $sym2) }
        │ ;

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#prod-MethodDefinition
###############################################################################################################

    <> method_definition → τasync? \*? property_name \( unique_formal_parameters? \) { function_body? }         ↦r { { type:env.typ.Method, ASYNC:!!$$sym1, GENERATOR:!!$$sym2, nodes:[$$sym3, $$sym5, $$sym8], pos } } 
        │ τget property_name \( \) { function_body? }                                                           ↦r { { type:env.typ.GetterMethod, nodes:[$$sym2, $sym6], pos } }
        │ τset property_name \( property_set_parameter_list \) { function_body? }                               ↦r { { type:env.typ.SetterMethod, nodes:[$$sym2, $$sym4, $sym7], pos } }

    <> property_set_parameter_list → formal_parameter 

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-comma-operator
###############################################################################################################

    <> expression → expression , assignment_expression                                                          ↦r { ( $sym1.type == env.typ.ExpressionList ? ( $sym1.nodes.push($sym3) , $sym1 )
                                                                                                                : { type: env.typ.ExpressionList, nodes: [$sym1, $sym3], pos } ) }
        │ assignment_expression                                                                                 
                    
###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-left-hand-side-expressions
###############################################################################################################

    <> left_hand_side_expression → new_expression       
        │ call_expression                               

    <> new_expression → member_expression 
        │ τnew new_expression                                                                                   ↦r { { type: env.typ.NewExpression, nodes:[$$sym2], pos } }

    <> member_expression → primary_expression                   
        │ member_expression \[ expression \]                                                                    ↦r { { type: env.typ.MemberExpression, nodes:[$$sym1, $$sym3], pos, COMPUTED:true } }
        │ member_expression . identifier_name                                                                   ↦r { ($sym3.type |= env.cls.PROPERTY_NAME, { type: env.typ.MemberExpression, nodes:[$$sym1, $$sym3], pos, COMPUTED:false }) }
        │ member_expression template_literal                                                                    ↦r { { type: env.typ.CallExpression, nodes:[$$sym1, $$sym2], pos, TEMPLATE:true } }
        │ super_property
        │ meta_property
        │ τnew member_expression arguments                                                                      ↦r { { type: env.typ.NewInstanceExpression, nodes:[$$sym2, $$sym3], pos } }

    <> super_property → τsuper . identifier_name                                                                ↦r { ($sym3.type |= env.cls.PROPERTY_NAME,{ type: env.typ.SuperExpression, nodes:[$$sym3], pos, COMPUTED:false } ) }
        │ τsuper \[ expression \]                                                                               ↦r { { type: env.typ.SuperExpression, nodes:[$$sym3], pos, COMPUTED:true } }

    <> meta_property → new_target

    <> new_target → τnew . τtarget                                                                              ↦r { { type: env.typ.NewTarget, pos } }

    <> call_expression → call_expression . identifier_name                                                      ↦r { ($sym3.type |= env.cls.PROPERTY_NAME,{ type: env.typ.MemberExpression, nodes:[$$sym1, $$sym3], pos, COMPUTED:false } )}
        │ super_call
        │ call_expression arguments                                                                             ↦r { { type: env.typ.CallExpression, nodes:[$$sym1, $$sym2], pos, TEMPLATE:true } }
        │ call_expression \[ expression \]                                                                      ↦r { { type: env.typ.MemberExpression, nodes:[$$sym1, $$sym3], pos, COMPUTED:true } }
        │ cover_call_expression_and_async_arrow_head                                                            
        │ call_expression template_literal                                                                      ↦r { { type: env.typ.CallExpression, nodes:[$$sym1, $$sym3], pos, TEMPLATE:true } }

    <> super_call → τsuper arguments                                                                            ↦r { { type: env.typ.SuperCall, nodes:[$$sym2], pos } }

    <> arguments → \( \)                                                                                        ↦r { { type: env.typ.Arguments, nodes:[], pos } }
        │ \( argument_list? ,? \)                                                                                ↦r { { type: env.typ.Arguments, nodes:$$sym2, pos } }

    <> argument_list → (assignment_expression │ ... assignment_expression ↦r=>Spread  )(+,)
                               


###############################################################################################################
#https://www.ecma-international.org/ecma-262/10.0/index.html#sec-primary-expression
###############################################################################################################

    <> primary_expression → τthis                                                                               ↦r { { type: env.typ.ThisLiteral, pos } }
        │ identifier_reference
        │ literal
        │ array_literal                                             
        │ object_literal                                            
        │ function_expression
        │ class_expression
        │ regular_expression_literal
        │ template_literal
        │ parenthesized                                                                                         ↦r ^reinterpretParenthesized

        #│ generator_expression
        #│ async_function_expression
        #│ async_generator_expression

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#prod-AwaitExpression
###############################################################################################################

    <> await_expression → τawait unary_expression                                                               ↦r { { type: env.typ.AwaitExpression, nodes:[$$sym2], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#prod-BindingExpression
###############################################################################################################

    <> assignment_expression → conditional_expression 
        │ yield_expression
        │ arrow_function
        │ left_hand_side_expression = assignment_expression                                                     ↦r { { type: env.typ.AssignmentExpression, symbol:"=",  nodes:[$sym1,$sym3], pos } }
        │ left_hand_side_expression assignement_operator assignment_expression                                  ↦r { { type: env.typ.AssignmentExpression, symbol:$sym2,  nodes:[$sym1,$sym3], pos } }
        
        #│ async_arrow_function

    <> assignement_operator → *=                                                        
        │ /=                                                                        
        │ %=                                                                        
        │ +=                                                                        
        │ -=                                                                        
        │ <<=                                                                       
        │ >>=                                                                       
        │ >>>=                                                                      
        │ &=                                                                        
        │ ^=                                                                        
        │ |=                                                                        
        │ **=                                                                       

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#prod-ConditionalExpression
###############################################################################################################

    <> conditional_expression → short_circuit_expression
        │ short_circuit_expression \? assignment_expression : assignment_expression                                ↦r { { type: env.typ.ConditionalExpression, nodes:[$$sym1, $$sym3, $$sym5], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-binary-logical-operators
###############################################################################################################
    
    <> short_circuit_expression → logical_or_expression

## https://tc39.es/ecma262/#prod-CoalesceExpression Latest
# TODO │ coalesce_expression
# TODO  <> coalesce_expression → (coalesce_expression │ bitwise_or_expression) ??  bitwise_or_expression        ↦r { { type: env.typ.CoalesceExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

    <> logical_or_expression → logical_and_expression 
        │ logical_or_expression || logical_and_expression                                                       ↦r { { type: env.typ.LogicalExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

    <> logical_and_expression → bitwise_or_expression 
        │ logical_and_expression && bitwise_or_expression                                                       ↦r { { type: env.typ.LogicalExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }




###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-binary-bitwise-operators
###############################################################################################################

    <> bitwise_or_expression → bitwise_xor_expression 
        │ bitwise_or_expression | bitwise_xor_expression                                                        ↦r { { type: env.typ.BitwiseExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

    <> bitwise_xor_expression → bitwise_and_expression 
        │ bitwise_xor_expression ^ bitwise_and_expression                                                       ↦r { { type: env.typ.BitwiseExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

    <> bitwise_and_expression → equality_expression 
        │ bitwise_and_expression & equality_expression                                                          ↦r { { type: env.typ.BitwiseExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-equality-operators
###############################################################################################################

    <> equality_expression → relational_expression 
        │ equality_expression == relational_expression                                                          ↦r { { type: env.typ.EqualityExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ equality_expression != relational_expression                                                          ↦r { { type: env.typ.EqualityExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ equality_expression === relational_expression                                                         ↦r { { type: env.typ.EqualityExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ equality_expression !== relational_expression                                                         ↦r { { type: env.typ.EqualityExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-relational-operators
###############################################################################################################

    <> relational_expression → shift_expression 
        │ relational_expression < shift_expression                                                              ↦r { { type: env.typ.RelationalExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ relational_expression >  shift_expression                                                             ↦r { { type: env.typ.RelationalExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ relational_expression <= shift_expression                                                             ↦r { { type: env.typ.RelationalExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ relational_expression >= shift_expression                                                             ↦r { { type: env.typ.RelationalExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ relational_expression τinstanceof shift_expression                                                    ↦r { { type: env.typ.InstanceOfExpression,  nodes:[$$sym1, $$sym3], pos } }
        │ relational_expression τin shift_expression                                                            ↦r { { type: env.typ.InExpression,  nodes:[$$sym1, $$sym3], pos } }   

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-bitwise-shift-operators
###############################################################################################################

    <> shift_expression → additive_expression 
        │ shift_expression << additive_expression                                                               ↦r { { type: env.typ.ShiftExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ shift_expression >> additive_expression                                                               ↦r { { type: env.typ.ShiftExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ shift_expression >>> additive_expression                                                              ↦r { { type: env.typ.ShiftExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-additive-operators
###############################################################################################################

    <> additive_expression → multiplicative_expression 
        │ additive_expression + multiplicative_expression                                                       ↦r { { type: env.typ.AdditiveExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ additive_expression - multiplicative_expression                                                       ↦r { { type: env.typ.AdditiveExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-multiplicative-operators
###############################################################################################################

    <> multiplicative_expression → exponentiation_expression 
        │ multiplicative_expression * exponentiation_expression                                                 ↦r { { type: env.typ.MultiplicativeExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ multiplicative_expression / exponentiation_expression                                                 ↦r { { type: env.typ.MultiplicativeExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ multiplicative_expression % exponentiation_expression                                                 ↦r { { type: env.typ.MultiplicativeExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-exp-operator
###############################################################################################################

    <> exponentiation_expression → unary_expression 
        │ update_expression ** exponentiation_expression                                                        ↦r { { type: env.typ.ExponentiationExpression, nodes:[$$sym1, $$sym3], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-unary-operators
###############################################################################################################

    <> unary_expression → update_expression 
        │ τdelete unary_expression                                                                              ↦r { { type: env.typ.DeleteExpression, nodes:[$$sym2], pos } }
        │ τvoid unary_expression                                                                                ↦r { { type: env.typ.VoidExpression, nodes:[$$sym2], pos } }
        │ τtypeof unary_expression                                                                              ↦r { { type: env.typ.TypeofExpression, nodes:[$$sym2], pos } }
        │ + unary_expression                                                                                    ↦r { { type: env.typ.UnaryExpression, symbol:$sym1, nodes:[$$sym2], pos } }
        │ - unary_expression                                                                                    ↦r { { type: env.typ.UnaryExpression, symbol:$sym1, nodes:[$$sym2], pos } }
        │ ~ unary_expression                                                                                    ↦r { { type: env.typ.UnaryExpression, symbol:$sym1, nodes:[$$sym2], pos } }
        │ ! unary_expression                                                                                    ↦r { { type: env.typ.UnaryExpression, symbol:$sym1, nodes:[$$sym2], pos } }
        │ await_expression

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-update-expressions
###############################################################################################################

    <> update_expression →  left_hand_side_expression 
        │ left_hand_side_expression  ++                                                                         ↦r { { type: env.typ.PostExpression, symbol:$$sym2, nodes:[$$sym1], pos } }
        │ left_hand_side_expression  --                                                                         ↦r { { type: env.typ.PostExpression, symbol:$$sym2, nodes:[$$sym1], pos } }
        │ ++ unary_expression                                                                                   ↦r { { type: env.typ.PreExpression, symbol:$$sym1, nodes:[$$sym2], pos } }
        │ -- unary_expression                                                                                   ↦r { { type: env.typ.PreExpression, symbol:$$sym1, nodes:[$$sym2], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#prod-CoverParenthesizedExpressionAndArrowParameterList
###############################################################################################################

    <> cover_parenthesized_expression_and_arrow_parameter_list → \( \)                                          ↦r { { type: env.typ.Parenthesized, nodes:[], pos } }
        │ \( expression , \)                                                                                    ↦r { { type: env.typ.Parenthesized, nodes:[$$sym2], pos } }
        │ \( (... binding_identifier ↦r=>Spread)  \)                                                            ↦r { { type: env.typ.Parenthesized, nodes:[$$sym2], pos } }
        │ \( (... binding_pattern ↦r=>Spread) \)                                                                ↦r { { type: env.typ.Parenthesized, nodes:[$$sym2], pos } }
        │ \( expression , (... binding_identifier ↦r=>Spread)  \)                                               ↦r { { type: env.typ.Parenthesized, nodes:[$$sym2, $$sym4], pos } }
        │ \( expression , (... binding_pattern ↦r=>Spread)  \)                                                  ↦r { { type: env.typ.Parenthesized, nodes:[$$sym2, $$sym4], pos } }                                                                                       
        │ parenthesized                                                                                         
    
    <> parenthesized → \( expression \)                                                                         ↦r { { type: env.typ.Parenthesized, nodes:[$$sym2], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#prod-BindingPattern
###############################################################################################################

    <> binding_pattern → object_binding_pattern
        │   array_binding_pattern

    <> object_binding_pattern → { }                                                                             ↦r { { type: env.typ.ObjectBinding, nodes:[], pos } }
        │ { binding_rest_property }                                                                             ↦r { { type: env.typ.ObjectBinding, nodes:[$sym2], pos } }
        │ { binding_property_list , binding_rest_property}                                                      ↦r { { type: env.typ.ObjectBinding, nodes:[...$sym2, $sym4], pos } }    
        │ { binding_property_list ,? }                                                                          ↦r { { type: env.typ.ObjectBinding, nodes:[...$sym2], pos } }    

    <> array_binding_pattern → \[ \]                                                                            ↦r { { type: env.typ.ArrayBinding, nodes:[], pos } }
        │ \[ elision binding_rest_element \]                                                                    ↦r { { type: env.typ.ArrayBinding, nodes:[$sym2, $sym3], pos } }
        │ \[ elision \]                                                                                         ↦r { { type: env.typ.ArrayBinding, nodes:[($sym2.count++, $sym2)], pos } }    
        │ \[ binding_rest_element \]                                                                            ↦r { { type: env.typ.ArrayBinding, nodes:[$sym2], pos } }    
        │ \[ binding_element_list \]                                                                            ↦r { { type: env.typ.ArrayBinding, nodes:[$sym2], pos } }    
        │ \[ binding_element_list , \]                                                                          ↦r { { type: env.typ.ArrayBinding, nodes:[...$sym2], pos } }    
        │ \[ binding_element_list , elision? \]                                                                 ↦r { { type: env.typ.ArrayBinding, nodes:[...$sym2, ($sym4.count++, $sym4)], pos } }    
        │ \[ binding_element_list , elision? binding_rest_element \]                                            ↦r { { type: env.typ.ArrayBinding, nodes:[...$sym2, $sym4, $sym5], pos } }    
        │ \[ binding_element_list , binding_rest_element \]                                                     ↦r { { type: env.typ.ArrayBinding, nodes:[...$sym2, $sym4], pos } }    

    <> binding_rest_property → ... binding_identifier                                                           ↦r=>Spread

    <> binding_property_list → binding_property(+,)                                                                         

    <> binding_element_list → binding_elision_element(+,)                                                       ↦r { $$sym1.flat() }

    <> binding_elision_element → elision? binding_element                                                       ↦r { [$sym1, $sym2] }                                                    

    <> binding_property → single_name_binding 
        │ property_name : binding_element                                                                       ↦r { { type:env.typ.PropertyBinding, nodes:[$sym1, $sym3],  pos  } }  

    <> binding_element → single_name_binding
        │ binding_pattern initializer                                                                           ↦r { { type:env.typ.BindingExpression, nodes: [$sym1, $sym2],  pos  } }
        │ binding_pattern

    <> single_name_binding → binding_identifier initializer                                                     ↦r { { type:env.typ.BindingExpression, nodes: [$sym1, $sym2],  pos  } }
        │ binding_identifier

    <> binding_rest_element → ... binding_identifier                                                            ↦r=>Spread
        │ ... binding_pattern                                                                                   ↦r=>Spread                                                                                              


###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#prod-RegularExpressionLiteral
###############################################################################################################

    <> regular_expression_literal → \/  regular_expression_characters(+") \/ regular_expression_flags?          ↦r { { type:env.typ.RegexLiteral, value:$sym2, flags:$sym4.value,  pos  } }

    <> regular_expression_characters →  θany 
        │ \\ θany                                                                                               ↦r { $sym1 + $sym2 } 

    <> regular_expression_flags → identifier_name  

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-object-initializer
###############################################################################################################

    <> object_literal →  { }                                                                                    ↦r { { type:env.typ.ObjectLiteral, nodes:[],  pos  } }
        │ { property_definition_list ,? }                                                                       ↦r { { type:env.typ.ObjectLiteral, nodes:$sym2,  pos  } }

    <> property_definition_list → property_definition                                                           ↦r { [$sym1] }
        │ property_definition_list , property_definition                                                        ↦r { $sym1.push($sym3), $sym1 }       

    <> property_definition →  cover_initialized_name                
        │ identifier_reference                                                                                  ↦r { $sym1.type |= env.cls.PROPERTY_NAME, $sym1 }
        │ method_definition                                                                                     
        │ ... assignment_expression                                                                             ↦r=>Spread
        │ property_name : assignment_expression                                                                 ↦r { { type:env.typ.PropertyBinding, nodes:[$sym1, $sym3],  pos  } }       

    <> property_name → literal_property_name                                                                    ↦r { $sym1.type |= env.cls.PROPERTY_NAME, $sym1 }
        │ computed_property_name                                                                                ↦r { $sym1.type |= env.cls.PROPERTY_NAME, $sym1 }

    <> literal_property_name → identifier_name                                                                  
        │ string_literal
        │ numeric_literal

    <> computed_property_name → \[ assignment_expression \]                                                     ↦r { { type: env.typ.ComputedProperty, nodes:[$sym2], pos } }

    <> cover_initialized_name → identifier_reference initializer                                                ↦{ sym[sym.length-2].type |= env.cls.PROPERTY_NAME } ↦r=>BindingExpression

    <> initializer → = assignment_expression                                                                    ↦r { $sym2 }
    

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-array-initializer
###############################################################################################################

    <> array_literal → \[ elision? \]                                                                           ↦r { { type: env.typ.ArrayLiteral, nodes:[($sym2.count++, $sym2)], pos } }
        │ \[ element_list \]                                                                                    ↦r { { type: env.typ.ArrayLiteral, nodes:$$sym2, pos } }
        │ \[ element_list , elision? \]                                                                         ↦r { { type: env.typ.ArrayLiteral, nodes:[...$$sym2, ($sym4.count++, $sym4)], pos } }

    <> element_list → elision? assignment_expression                                                            ↦r { [$sym1, $sym2 ] }
        │ elision? spread_element                                                                               ↦r { [ $sym1,$sym2 ] }
        │ element_list , elision? assignment_expression                                                         ↦r { [ ...$sym1, $sym3, $sym4 ] }
        │ element_list , elision? spread_element                                                                ↦r { [ ...$sym1, $sym3, $sym4 ] }

    <> elision → ,                                                                                              ↦r { { type: env.typ.Elision, count:0, pos } }
        │ elision ,                                                                                             ↦r { $sym1.count++ , $sym1 }

    <> spread_element → ... assignment_expression                                                               ↦r=>Spread

###############################################################################################################
#https://www.ecma-international.org/ecma-262/#prod-TemplateLiteral
###############################################################################################################

    <> template_literal → no_substitute_template
        │ substitute_template 

    <> no_substitute_template → ↦^parseTemplate ` `                                                             ↦r { { type: env.typ.Template, nodes:[ { quote_type:"", type: env.typ.StringLiteral, value:$sym1,  pos  } ], NO_SUBSTITUTE:true, pos } }

    <> substitute_template → template_head expression template_spans                                            ↦r { $sym3.unshift($sym1, $sym2), { type: env.typ.Template, nodes:$$sym3, pos } }

    <> template_spans → template_tail                                                                           ↦r { [ $sym1 ] }
        │ template_middle_list template_tail                                                                    ↦r { $sym1.push($sym2), $sym1 }           

    <> template_middle_list → template_middle expression                                                        ↦r { [ $sym1, $sym2 ] }
        │ template_middle_list template_middle expression                                                       ↦r { $sym1.push($sym2, $sym3), $sym1 }

    <> template_head →      ↦^parseTemplate  `  \${                                                             ↦r { { type:env.typ.TemplateHead, value:$sym1, pos  } }

    <> template_middle →    ↦^parseTemplate \}  \${                                                             ↦r { { type:env.typ.TemplateMiddle, value:$sym1,  pos  } }

    <> template_tail →      ↦^parseTemplate \}  `                                                               ↦r { { type:env.typ.TemplateTail, value:$sym1,  pos  } }

    <> template_characters → template_string_data (*")                                                          ↦r { { type: env.typ.StringLiteral, value:$sym1,  pos  } }
    
    <> template_string_data →  θnl │ θws │ θsym │ θop │ θcb │ θob │ θnum │ θid │ θany │ escaped_sequence                                      
                                                                                                              

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-language-lexical-grammar
###############################################################################################################

    <> literal → boolean_literal                
        │ null_literal
        │ string_literal                    
        │ numeric_literal
        │ bigint       

    <> string_literal → ↦^parseString \" \"                                                                     ↦r { { quote_type:$sym2, type: env.typ.StringLiteral, value:$$sym1 || "",  pos  } }
        │ ↦^parseString \' \'                                                                                   ↦r { { quote_type:$sym2, type: env.typ.StringLiteral, value:$$sym1 || "",  pos  } }

    <> string_data →   θnl │ θws │ θsym │ θop │ θcb │ θob │ θnum │ θid │ θany │ escaped_sequence                     #↦r { { type: env.typ.StringLiteral, value:$sym1,  pos  } }

    ##<> escaped_sequence → \\ ( ` │ ' │ " │ τb │ τf │ τn │ τr │ τy │ τv │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │ hex_escape_sequence │ θany )   

    <> escaped_sequence → \\ (  θnl │ θws │ θsym │ θop │ θcb │ θob │ θnum │ θid │ θany )
                                                                                                                ↦r { $sym1 + $sym2}

    #<> hex_escape_sequence → τx def::hex_digit def::hex_digit                                                   ↦r { $sym1 + $sym2 + $sym3 }

    #<> unicode_escape_sequence → τu def::hex_digit def::hex_digit def::hex_digit def::hex_digit                 ↦r { $sym1 + $sym2 + $sym3 + $sym4 + $sym5 }
    #    │ τu \{ def::hex \}                                                                                     ↦r { $sym1 + $sym2 + $sym3 + $sym4 }

    <> numeric_literal → -? number                                                                               ↦r { { type: env.typ.NumericLiteral, value:$sym2.original_val, computed_value:$sym2.val, value_data:$sym1, pos, NEGATIVE:!!$$sym1 } }
    
    <> bigint →  -? θnum τn                                                                                     ↦r { { type: env.typ.BigIntLiteral, value:$sym2, valpos, NEGATIVE:!!$$sym1 } }

    <> number → def::float 
        │ def::octal 
        │ def::binary 
        │ def::hex                                                             

    <> null_literal →  τnull                                                                                    ↦r { { type: env.typ.NullLiteral, pos  } }

    <> boolean_literal → τtrue                                                                                  ↦r { { type: env.typ.BooleanLiteral, value: $$sym1,  pos  } }
        │ τfalse                                                                                                ↦r { { type: env.typ.BooleanLiteral, value: $$sym1,  pos  } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-names-and-keywords
###############################################################################################################

    <> label_identifier → identifier                                                                            ↦r { $sym1.type = env.typ.IdentifierLabel, $sym1 }   
            #│ τyield                          
            #│ τawait                           

    <> identifier_reference → identifier                                                                        ↦r { $sym1.type = env.typ.IdentifierReference, $sym1 }
            #│ τyield                               
            #│ τawait                               

    <> binding_identifier → identifier                                                                          ↦r { $sym1.type = env.typ.IdentifierBinding, $sym1 }
            #│ τyield                               
            #│ τawait                               

    <> identifier → def::js_identifier                                                                          ↦r { { type: env.typ.Identifier, value:$sym1,  pos  } }   
        │ unreserved_word                                                                                       ↦r { { type: env.typ.Identifier, value:$sym1,  pos  } }   

    <> identifier_name → def::js_identifier                                                                     ↦r { { type: env.typ.IdentifierName, value:$sym1,  pos  } }              
        │ reserved_word                                                                                         ↦r { { type: env.typ.IdentifierName, value:$sym1,  pos  } } 
        │ unreserved_word                                                                                       ↦r { { type: env.typ.IdentifierName, value:$sym1,  pos  } }

    <> unreserved_word → τasync
        │ τget
        │ τset
        │ τtarget
        │ τas
        │ τfrom


    <> reserved_word →  keyword
        │ future_reserved_word
        │ τnull
        │ τtrue 
        │ τfalse                                                                                                               

    <> future_reserved_word → 
        │ τimplements 
        │ τpackage 
        │ τprotected 
        │ τinterface
        │ τprivate
        │ τpublic

    <> keyword → τawait
        │ τbreak
        │ τcase
        │ τcatch
        │ τclass
        │ τconst
        │ τcontinue
        │ τdebugger
        │ τdefault
        │ τdelete
        │ τdo
        │ τelse
        │ τexport
        │ τextends
        │ τfinally
        │ τfor
        │ τfunction
        │ τif
        │ τimport
        │ τin
        │ τinstanceof
        │ τnew
        │ τreturn
        │ τsuper
        │ τswitch
        │ τthis
        │ τthrow
        │ τtry
        │ τtypeof
        │ τvar
        │ τvoid
        │ τwhile
        │ τwith
        │ τyield
