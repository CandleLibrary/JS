@NAME JavaScriptParser

@IGNORE g:ws g:nl tk:comments

@IMPORT default-productions as def

####################

f:BindingExpression { { type:env.typ.BindingExpression, symbol:"=", nodes: [$sym1, $sym2],  pos  } }

f:Spread{ { type:env.typ.Spread, nodes: [$sym2],  pos  } }

###############################################################################################################
###############################################################################################################
###############################################################################################################
# Productions
###############################################################################################################
###############################################################################################################
###############################################################################################################

<> javascript > start                                                                                           f:r { env.IS_MODULE = false, $sym1 }

<> start > module                                                                                               f:r { { type:(env.IS_MODULE) ? env.typ.Module : env.typ.Script, nodes:$sym1, pos  } }

### Meta

<> comments > \/* ( g:ws | g:nl | g:id | g:num | g:sym )(*) \*/
    | \// ( g:ws | g:id | g:num | g:sym )(*) g:nl

<> asi > ( \; | ?={ | ?=g:nl | ?=$eof )

###############################################################################################################
###############################################################################################################
## MODULES
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-ecmascript-language-scripts-and-modules
###############################################################################################################

    <> module > module_body      

    <> module_body > module_item(+)                                                                         

    <> module_item > import_declaration                                                                         ↦ { env.IS_MODULE = true }
        │ export_declaration                                                                                    ↦ { env.IS_MODULE = true }
        │ statement_list_item

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#prod-ImportDeclaration
###############################################################################################################

    <> import_declaration > t:import import_clause from_clause asi                                              f:r { { type:env.typ.ImportDeclaration, nodes:[$sym2, $sym3], pos } }
        │ t:import module_specifier asi                                                                         f:r { { type:env.typ.ImportDeclaration, nodes:[null, $sym2], pos } }

    <> import_clause > imported_default_binding                                                                 f:r { { type:env.typ.ImportClause, nodes:[$$sym1], pos } }
        │ name_space_import                                                                                     f:r { { type:env.typ.ImportClause, nodes:[$$sym1], pos } }
        │ named_imports                                                                                         f:r { { type:env.typ.ImportClause, nodes:[$$sym1], pos } }
        │ imported_default_binding , name_space_import                                                          f:r { { type:env.typ.ImportClause, nodes:[$$sym1, $$sym3], pos } }
        │ imported_default_binding , named_imports                                                              f:r { { type:env.typ.ImportClause, nodes:[$$sym1, $$sym3], pos } }

    <> imported_default_binding > imported_binding                                                              f:r { $sym1.type = env.typ.IdentifierDefault, $sym1 }

    <> name_space_import > * t:as imported_binding                                                               f:r { { type:env.typ.NameSpaceImport, nodes:[$$sym3], pos } }

    <> named_imports > { import_specifier(*\, ) ,? }                                                            f:r { { type:env.typ.NamedImports, nodes:$$sym2 || [], pos } }

    <> from_clause > t:from module_specifier                                                                     f:r { { type:env.typ.FromClause, nodes:[$sym2], pos } }

    <> import_specifier > imported_binding                                                                      f:r { { type:env.typ.Specifier, nodes:[$sym1], pos } }
        │ identifier t:as imported_binding                                                                       f:r { { type:env.typ.Specifier, nodes:[$sym1, $sym3], pos } }

    <> module_specifier > string_literal                                                                        

    <> imported_binding > identifier                                                                            f:r { $sym1.type = env.typ.IdentifierModule, $sym1 }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-exports
###############################################################################################################

    <> export_declaration > t:export * from_clause asi                                                    f:r { { type:env.typ.ExportDeclaration, nodes:[null, $sym3], DEFAULT:false, pos } }
        │ t:export export_clause from_clause? asi                                                         f:r { { type:env.typ.ExportDeclaration, nodes:[$sym2, $$sym3], DEFAULT:false, pos } }
        │ t:export variable_statement                                                                            f:r { { type:env.typ.ExportDeclaration, nodes:[$sym2], DEFAULT:false, pos } }
        │ t:export declaration                                                                                   f:r { { type:env.typ.ExportDeclaration, nodes:[$sym2], DEFAULT:false, pos } }
        │ t:export t:default hoistable_declaration                                                                f:r { { type:env.typ.ExportDeclaration, nodes:[$sym3], DEFAULT:true, pos } }
        │ t:export t:default class_declaration                                                                    f:r { { type:env.typ.ExportDeclaration, nodes:[$sym3], DEFAULT:true, pos } }
        │ t:export t:default                                                                                      

            (EXC t:function )
            (EXC t:class )
            (EXC t:async t:function )
        
            assignment_expression asi                                                                           f:r { { type:env.typ.ExportDeclaration, nodes:[$sym3], DEFAULT:true, pos } }

    <> export_clause > { export_specifier(*\, ) ,? }                                                            f:r { { type:env.typ.ExportClause, nodes:$$sym2||[], pos } }

    <> export_specifier >  identifier                                                                           f:r { { type:env.typ.Specifier, nodes:[$sym1], pos } }
        │ identifier t:as identifier                                                                             f:r { { type:env.typ.Specifier, nodes:[$sym1, $sym3], pos } }

###############################################################################################################
###############################################################################################################
## SCRIPT
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-ecmascript-language-scripts-and-modules
###############################################################################################################

    <> script > script_body                                                                                     f:r { { type:env.typ.Script, nodes:$sym1, pos } }

    <> script_body > statement_list                                                                            

############################################################################################################### 
###############################################################################################################
## STATEMENTS
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#prod-Statement
###############################################################################################################

    <> statement_list > statement_list_item                                                                     f:r { [ $sym1 ] }
        │ statement_list statement_list_item                                                                    f:r { [ ...$sym1, $sym2 ] }                             

    <> statement_list_item > statement 
        │ declaration


    <> statement > block_statement 
        │ 
            (EXC \{ )
            (EXC t:function )
            (EXC t:class )
            (EXC t:let \[ )
            (EXC t:async t:function )

            expression_statement                           

        │ labeled_statement
        │ variable_statement
        │ empty_statement
        │ if_statement
        │ breakable_statement 
        │ continue_statement
        │ break_statement
        │ return_statement
        │ with_statement
        │ throw_statement
        │ try_statement
        │ debugger_statement

    <> declaration > class_declaration
        │ hoistable_declaration
        │ lexical_declaration

    <> hoistable_declaration > function_declaration
        #│ generator_declaration
        #│ async_function_declaration
        #│ async_generator_declaration

    <> breakable_statement > iteration_statement
        │ switch_statement


###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-block
###############################################################################################################

    <> block_statement > block                          

    <> block > { statement_list? }                                                                               f:r { { type: env.typ.BlockStatement, nodes: $$sym2 || [], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-empty-statement
###############################################################################################################

    <> empty_statement > ;                                                                                      f:r { { type: env.typ.EmptyStatement, pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-expression-statement
###############################################################################################################

    <> expression_statement > expression asi                                                                     f:r { { type: env.typ.ExpressionStatement, nodes:[$sym1], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-expression-statement
###############################################################################################################

    <> if_statement > t:if \( expression \) statement (t:else statement)?                                         f:r { { type: env.typ.IfStatement, nodes:[$$sym3, $$sym5, $$sym6], pos } }                

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-iteration-statements
###############################################################################################################

    <> iteration_statement > t:do statement t:while \( expression \) asi                                         f:r { { type: env.typ.DoStatement, nodes:[$$sym2, $$sym5], pos } }

        │ t:while \( expression \) statement                                                                     f:r { { type: env.typ.WhileStatement, nodes:[$$sym3, $$sym5], pos } }
        
        │ t:for \( (
            (EXC t:let \[ ) expression 
            │ t:var variable_declaration_list f:r { { type:env.typ.VariableDeclaration, nodes:$sym2, pos } }
            )? ; expression? ; expression? \)  statement                                                 
                                                                                                                f:r { { type: env.typ.ForStatement, nodes:[$$sym3, $$sym5, $$sym7, $$sym9], LEX:false, pos } }

        │ t:for \( lexical_declaration expression? ; expression? \) statement                                   f:r { { type: env.typ.ForStatement, nodes:[$$sym3, $$sym4, $$sym6, $$sym8], LEX:true, pos } }                                                                           
                                                                                                                                                                                                                                                                            
        │ t:for \( (
                (EXC t:let \[ ) left_hand_side_expression
                │ t:var for_binding f:r { { type:env.typ.VariableDeclaration, nodes:[$sym1], pos }  }
                │ for_declaration
            ) t:in expression \) statement                                                                      f:r { { type: env.typ.ForInStatement, nodes:[$$sym3, $$sym5, $$sym7], pos } } 

        │ t:for t:await? \( (
                (EXC t:let \[ ) left_hand_side_expression
                │ t:var for_binding f:r { { type:env.typ.VariableDeclaration, nodes:[$sym1],lex }  }
                │ for_declaration
            ) t:of expression \) statement                                                                      f:r { { type: env.typ.ForOfStatement, nodes:[$$sym4, $$sym6, $$sym8], pos, AWAIT:!!$$sym2 } }

    <> for_declaration > let_or_const for_binding                                                               f:r { { type: env.typ.LexicalBinding, nodes:[$$sym2], symbol:$$sym1, pos } }

    <> for_binding > binding_identifier 
        │ binding_pattern 

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-continue-statement
###############################################################################################################

    <> continue_statement > t:continue (RED g:nl) label_identifier? asi                                             f:r { { type: env.typ.ContinueStatement, nodes:$$sym2 ? [$$sym2] : [], pos } }  

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-break-statement
###############################################################################################################

    <> break_statement > t:break label_identifier? asi                                                             f:r { { type: env.typ.BreakStatement, nodes:[$$sym2], pos } }


###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-return-statement
###############################################################################################################

    <> return_statement > t:return expression? asi                                                                 f:r { { type:env.typ.ReturnStatement, nodes:[$sym2], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-throw-statement
###############################################################################################################

    <> throw_statement > t:throw expression asi                                                                    f:r { { type:env.typ.ThrowStatement, nodes:[$$sym2], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-with-statement
###############################################################################################################

    <> with_statement > t:with \( expression \) statement                                                        f:r { { type:env.typ.WithStatement, nodes:[$$sym3, $$sym5], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-switch-statement
###############################################################################################################

    <> switch_statement > t:switch \( expression \) case_block                                                   f:r { { type:env.typ.SwitchStatement, nodes:[$$sym3, $$sym5], pos } }

    <> case_block > { case_clauses? default_clause? case_clauses? }                                             f:r { { type:env.typ.CaseBlock, nodes:[...$sym2, $sym3, ...$sym4], pos } }

    <> case_clauses > case_clause(+)

    <> case_clause > t:case expression : statement_list?                                                         f:r { { type:env.typ.CaseClause, nodes:[$$sym2, ...$sym4], pos } }

    <> default_clause > t:default : statement_list?                                                              f:r { { type:env.typ.DefaultClause, nodes:[...$sym3], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-labeled-statements
###############################################################################################################

    <> labeled_statement > label_identifier : labeled_item                                                    f:r { { type:env.typ.LabeledStatement, nodes:[$$sym1, $$sym3], pos } }

    <> labeled_item > statement
        │ function_declaration

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-try-statement
###############################################################################################################

    <> try_statement > t:try block catch                                                                         f:r { { type:env.typ.TryStatement, nodes:[$$sym2,$$sym3,null], pos } }
        │ t:try block finally                                                                                    f:r { { type:env.typ.TryStatement, nodes:[$$sym2,null,$$sym3], pos } }
        │ t:try block catch  finally                                                                             f:r { { type:env.typ.TryStatement, nodes:[$$sym2,$$sym3,$$sym4], pos } }

    <> catch > t:catch \( catch_parameter \) block                                                               f:r { { type:env.typ.CatchClause, nodes:[$$sym3, $$sym5], pos } }

    <> finally > t:finally block                                                                                 f:r { { type:env.typ.FinallyClause, nodes:[$$sym2], pos } }

    <> catch_parameter > binding_identifier 
        │ binding_pattern

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-debugger-statement
###############################################################################################################

    <> debugger_statement > t:debugger asi                                                                         f:r { { type:env.typ.DebuggerStatement, pos } }

###############################################################################################################
###############################################################################################################
## DECLARATIONS
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-variable-statement
###############################################################################################################

    <> variable_statement > t:var variable_declaration_list asi                                                    f:r { { type:env.typ.VariableStatement, nodes:$sym2, pos } }

    <> variable_declaration_list > variable_declaration(+\, )                                                         

    <> variable_declaration > binding_identifier initializer                                                    f:r => BindingExpression
        │ binding_identifier                                        
        │ binding_pattern initializer                                                                           f:r => BindingExpression


###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-let-and-const-declarations
###############################################################################################################

        <> lexical_declaration > let_or_const binding_list asi                                                    f:r { { type:env.typ.LexicalDeclaration, symbol:$sym1, nodes:$sym2, pos } }

        <> let_or_const > t:let                                                                                  f:r { "let" }
            │ t:const                                                                                            f:r { "const" }

        <> binding_list > lexical_binding(+\, )                                                                            

        <> lexical_binding > binding_identifier
            │ binding_identifier initializer                                                                    f:r => BindingExpression
            │ binding_pattern initializer                                                                       f:r => BindingExpression

###############################################################################################################
###############################################################################################################
## FUNCTIONS
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-function-definitions
###############################################################################################################

    ## Modified to include async and function generator elements

    <> function_declaration > t:async? t:function \* ? binding_identifier? 
                                \( formal_parameters? \) { function_body }                                     f:r { { type:env.typ.FunctionDeclaration, ASYNC:!!$$sym1, GENERATOR:!!$$sym3, nodes:[$$sym4,$$sym6,$$sym9], pos } }

    <> function_expression > function_declaration                                                              f:r { ( sym1.type = env.typ.FunctionExpression, sym1 ) }

    <> unique_formal_parameters > formal_parameters

    <> formal_parameters > function_rest_parameter                                                              f:r { { type:env.typ.FormalParameters, nodes:[$sym1], pos } }
         │ formal_parameter_list ,?                                                                             f:r { { type:env.typ.FormalParameters, nodes:$sym1, pos } }
         │ formal_parameter_list , function_rest_parameter                                                      f:r { { type:env.typ.FormalParameters, nodes:[...$sym1,$$sym3], pos } }

    <> formal_parameter_list > formal_parameter(+\, )                                                                     

    <> function_rest_parameter > binding_rest_element           

    <> formal_parameter > binding_element

    <> function_body > function_statement_list                                                                  f:r { { type:env.typ.FunctionBody, nodes:$sym1 || [], pos } }

    <> function_statement_list > statement_list?

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#prod-GeneratorExpression
###############################################################################################################

    # <> async_function_declaration > t:async t:function binding_identifier? \( formal_parameters? \) { async_function_body? }     

    # <> async_function_expression > t:async t:function \( formal_parameters? \) { async_function_body? }                          

    # <> async_function_method > t:async property_name \( unique_formal_parameters? \) { async_function_body? }                   

    # <> async_function_body > function_body

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#prod-AsyncGeneratorExpression
###############################################################################################################

    # <> async_generator_method > t:async \* property_name \( unique_formal_parameters? \) { async_generator_body? }               

    # <> async_generator_declaration > t:async t:function \* binding_identifier? \( formal_parameters? \) { async_function_body? }  

    # <> async_generator_expression > t:async t:function \* \( formal_parameters? \) { async_function_body? }                       

    # <> async_generator_body > function_body

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#prod-GeneratorExpression
###############################################################################################################

    # <> generator_method > \* property_name  \( unique_formal_parameters? \) { generator_body }                                  

    # <> generator_declaration > t:function \* binding_identifier \( formal_parameters? \) { generator_body }                       

    # <> generator_expression > t:function \* \( formal_parameters? \) {generator_body}                                             

    # <> generator_body > function_body

    <> yield_expression > t:yield g:nl                                                                          f:r { { type: env.typ.YieldExpression, nodes:[], pos } }
        │ t:yield ( \* )? assignment_expression                                                                 f:r { { type: env.typ.YieldExpression, nodes:[$$sym3], pos, GENERATOR:!!$$sym2 } }


###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-arrow-function-definitions
###############################################################################################################

    <> arrow_function > t:async? arrow_parameters => concise_body                                                f:r { { type:env.typ.ArrowFunction, ASYNC:!!$$sym1, nodes:[$$sym2,$$sym4], pos } }

    <> arrow_parameters > identifier_reference                                                                  f:r { $sym1.type = env.typ.IdentifierBinding, $sym1 }    
        │ cover_parenthesized_expression_and_arrow_parameter_list                                               f:r ^reinterpretArrowParameters

    <> concise_body > (EXC \{ ) assignment_expression 
        │ { function_statement_list }                                                                           f:r { { type: env.typ.BlockStatement, nodes: $sym2, pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-async-arrow-function-definitions
###############################################################################################################

    #    <> async_arrow_function > t:async async_arrow_parameters => async_concise_body                          ↦c ^async_arrow

    #    <> async_arrow_parameters > binding_identifier 
    #        │ cover_call_expression_and_async_arrow_head                                                       

    #    <> async_concise_body > (EXC \{ ) assignment_expression 
    #        │ { function_statement_list }                                                                      f:r { $sym2 }

    <> cover_call_expression_and_async_arrow_head > member_expression arguments                                 f:r { { type: env.typ.CallExpression, nodes:[$sym1, $sym2], pos } }

###############################################################################################################
###############################################################################################################
## CLASSES
############################################################################################################### 
###############################################################################################################

###############################################################################################################
# https://www.ecma-international.org/ecma-262/index.html#sec-class-definitions
###############################################################################################################

    <> class_declaration > t:class binding_identifier? class_heritage? { class_body? }                           f:r { { type:env.typ.Class, nodes:[$$sym2, $$sym3, ...$sym5], pos } }

    <> class_expression > t:class binding_identifier? class_heritage? { class_body? }                            f:r { { type:env.typ.Class, nodes:[$$sym2, $$sym3, ...$sym5], pos } }

    <> class_heritage > t:extends left_hand_side_expression                          

    <> class_body > class_element                                                                               f:r { [$sym1 ] } 
        | class_body class_element                                                                              f:r { $sym1.concat($sym2) } 
        | class_body asi                                                                                        f:r { $sym1 }
        | ;                                                                                                     f:r { [] }

    <> class_element > method_definition 
        │ t:static method_definition                                                                             f:r { ( $sym2.STATIC = true, $sym2) }
        

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#prod-MethodDefinition
###############################################################################################################

    <> method_definition > t:async? (\* )? property_name \( unique_formal_parameters? \) { function_body? }      f:r { { type:env.typ.Method, ASYNC:!!$$sym1, GENERATOR:!!$$sym2, nodes:[$$sym3, $$sym5, $$sym8], pos } } 
        │ t:get property_name \( \) { function_body? }                                                           f:r { { type:env.typ.GetterMethod, nodes:[$$sym2, $sym6], pos } }
        │ t:set property_name \( property_set_parameter_list \) { function_body? }                               f:r { { type:env.typ.SetterMethod, nodes:[$$sym2, $$sym4, $sym7], pos } }

    <> property_set_parameter_list > formal_parameter 

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-comma-operator
###############################################################################################################

    <> expression > expression , assignment_expression                                                          f:r { ( $sym1.type == env.typ.ExpressionList ? ( $sym1.nodes.push($sym3) , $sym1 )
                                                                                                                : { type: env.typ.ExpressionList, nodes: [$sym1, $sym3], pos } ) }
        │ assignment_expression                                                                                 
                    
###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-left-hand-side-expressions
###############################################################################################################

    <> left_hand_side_expression > new_expression       
        │ call_expression         
        | optional_expression                      

    <> new_expression > member_expression 
        │ t:new new_expression                                                                                   f:r { { type: env.typ.NewExpression, nodes:[$$sym2], pos } }

    <> member_expression > primary_expression                   
        │ member_expression \[ expression \]                                                                    f:r { { type: env.typ.MemberExpression, nodes:[$$sym1, $$sym3], pos, COMPUTED:true } }
        │ member_expression . identifier_name                                                                   f:r { ($sym3.type |= env.cls.PROPERTY_NAME, { type: env.typ.MemberExpression, nodes:[$$sym1, $$sym3], pos, COMPUTED:false }) }
        │ member_expression template_literal                                                                    f:r { { type: env.typ.CallExpression, nodes:[$$sym1, $$sym2], pos, TEMPLATE:true } }
        │ super_property
        │ meta_property
        │ t:new member_expression arguments                                                                      f:r { { type: env.typ.NewInstanceExpression, nodes:[$$sym2, $$sym3], pos } }

    <> super_property > t:super . identifier_name                                                                f:r { ($sym3.type |= env.cls.PROPERTY_NAME,{ type: env.typ.SuperExpression, nodes:[$$sym3], pos, COMPUTED:false } ) }
        │ t:super \[ expression \]                                                                               f:r { { type: env.typ.SuperExpression, nodes:[$$sym3], pos, COMPUTED:true } }

    <> meta_property > new_target
        | import_meta
    
    ##
    # 2020 https://www.ecma-international.org/ecma-262/#prod-ImportMeta
    ##
    <> import_meta > t:import . t:meta                                                                            f:r { { type: env.typ.ImportMeta, pos } }

    <> new_target > t:new . t:target                                                                              f:r { { type: env.typ.NewTarget, pos } }

    <> call_expression > call_expression . identifier_name                                                      f:r { ($sym3.type |= env.cls.PROPERTY_NAME,{ type: env.typ.MemberExpression, nodes:[$$sym1, $$sym3], pos, COMPUTED:false } )}
        │ super_call
        │ import_call
        │ call_expression arguments                                                                             f:r { { type: env.typ.CallExpression, nodes:[$$sym1, $$sym2], pos, TEMPLATE:false } }
        │ call_expression \[ expression \]                                                                      f:r { { type: env.typ.MemberExpression, nodes:[$$sym1, $$sym3], pos, COMPUTED:true } }
        │ cover_call_expression_and_async_arrow_head                                                            
        │ call_expression template_literal                                                                      f:r { { type: env.typ.CallExpression, nodes:[$$sym1, $$sym3], pos, TEMPLATE:true } }

    <> super_call > t:super arguments                                                                            f:r { { type: env.typ.SuperCall, nodes:[$$sym2], pos } }
    
    ##
    # 2020 https://www.ecma-international.org/ecma-262/#prod-ImportCall
    ##
    <> import_call > t:import \( assignment_expression \)                                                         f:r { { type: env.typ.ImportCall, nodes:[$$sym3], pos } }

    <> arguments >  \( argument_list? ,? \)                                                                      f:r { { type: env.typ.Arguments, nodes:$$sym2 || [], pos } }

    <> argument_list > (assignment_expression │ \... assignment_expression f:r=>Spread  )(+\, )

###############################################################################################################
# 2020 https://www.ecma-international.org/ecma-262/#prod-OptionalExpression
###############################################################################################################
                               
    <> optional_expression > member_expression optional_chain                                                   f:r { { type: env.typ.OptionalMemberExpression, nodes:[$$sym1, $$sym2], pos, COMPUTED:false } }
        │ call_expression optional_chain                                                                        f:r { { type: env.typ.OptionalMemberExpression, nodes:[$$sym1, $$sym2], pos, COMPUTED:false } }
        │ optional_expression optional_chain                                                                    f:r { { type: env.typ.OptionalMemberExpression, nodes:[$$sym1, $$sym2], pos, COMPUTED:false } }

    <> optional_chain > \?. arguments                                                                           
        | \?. \[ expression \]                                                                                   f:r { $sym3 }
        | \?. identifier_name                                                                                  
        | \?. template_literal                                                                                  
        | optional_chain arguments                                                                              f:r { { type: env.typ.CallExpression, nodes:[$$sym1, $$sym2], pos, TEMPLATE:false } }
        | optional_chain \[ expression \]                                                                       f:r { { type: env.typ.MemberExpression, nodes:[$$sym1, $$sym3], pos, COMPUTED:true } }
        | optional_chain \. identifier_name                                                                     f:r { ($sym3.type |= env.cls.PROPERTY_NAME, { type: env.typ.MemberExpression, nodes:[$$sym1, $$sym3], pos, COMPUTED:false }) }
        | optional_chain template_literal                                                                       f:r { { type: env.typ.CallExpression, nodes:[$$sym1, $$sym2], pos, TEMPLATE:true } }
        



###############################################################################################################
#https://www.ecma-international.org/ecma-262/11.0/index.html#sec-primary-expression
###############################################################################################################

    <> primary_expression > t:this                                                                               f:r { { type: env.typ.ThisLiteral, pos } }
        │ identifier_reference
        │ literal
        │ array_literal                                             
        │ object_literal                                            
        │ function_expression
        │ class_expression
        │ regular_expression_literal
        │ template_literal
        │ parenthesized                                                                                         f:r ^reinterpretParenthesized

        #│ generator_expression
        #│ async_function_expression
        #│ async_generator_expression

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#prod-AwaitExpression
###############################################################################################################

    <> await_expression > t:await unary_expression                                                               f:r { { type: env.typ.AwaitExpression, nodes:[$$sym2], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#prod-BindingExpression
###############################################################################################################

    <> assignment_expression > conditional_expression 
        │ yield_expression
        │ arrow_function
        │ left_hand_side_expression = assignment_expression                                                     f:r { { type: env.typ.AssignmentExpression, symbol:"=",  nodes:[$sym1,$sym3], pos } }
        │ left_hand_side_expression assignment_operator assignment_expression                                   f:r { { type: env.typ.AssignmentExpression, symbol:$sym2,  nodes:[$sym1,$sym3], pos } }
        
        #│ async_arrow_function

    <> assignment_operator > *=                                                        
        │ \/=                                                                        
        │ \%=                                                                        
        │ \+=                                                                        
        │ \-=                                                                        
        │ \<<=                                                                       
        │ \>>=                                                                       
        │ \>>>=                                                                      
        │ \&=                                                                        
        │ \^=                                                                        
        │ \|=                                                                        
        │ \**=                                                                       

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#prod-ConditionalExpression
###############################################################################################################

    <> conditional_expression > short_circuit_expression
        │ short_circuit_expression \? assignment_expression : assignment_expression                            f:r { { type: env.typ.ConditionalExpression, nodes:[$$sym1, $$sym3, $$sym5], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-binary-logical-operators
###############################################################################################################
    
    <> short_circuit_expression > logical_or_expression
        │ coalesce_expression
    

    <> logical_or_expression > logical_and_expression 
        │ logical_or_expression \|| logical_and_expression                                                      f:r { { type: env.typ.LogicalExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

    <> logical_and_expression > bitwise_or_expression 
        │ logical_and_expression \&& bitwise_or_expression                                                       f:r { { type: env.typ.LogicalExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

    ##
    # 2020 https://www.ecma-international.org/ecma-262/#prod-CoalesceExpression
    ##

    <> coalesce_expression >  coalesce_expression_head \?? bitwise_or_expression                                f:r { { type: env.typ.CoalesceExpression, nodes:[$$sym1, $$sym3], pos } }

    <> coalesce_expression_head > ( coalesce_expression │ bitwise_or_expression  )          




###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-binary-bitwise-operators
###############################################################################################################

    <> bitwise_or_expression > bitwise_xor_expression 
        │ bitwise_or_expression \| bitwise_xor_expression                                                        f:r { { type: env.typ.BitwiseExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

    <> bitwise_xor_expression > bitwise_and_expression 
        │ bitwise_xor_expression ^ bitwise_and_expression                                                       f:r { { type: env.typ.BitwiseExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

    <> bitwise_and_expression > equality_expression 
        │ bitwise_and_expression & equality_expression                                                          f:r { { type: env.typ.BitwiseExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

    <> equality_expression > relational_expression 
        │ equality_expression \== relational_expression                                                          f:r { { type: env.typ.EqualityExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ equality_expression \!= relational_expression                                                          f:r { { type: env.typ.EqualityExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ equality_expression \=== relational_expression                                                         f:r { { type: env.typ.EqualityExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ equality_expression \!== relational_expression                                                         f:r { { type: env.typ.EqualityExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-relational-operators
###############################################################################################################

    <> relational_expression > shift_expression 
        │ relational_expression < shift_expression                                                              f:r { { type: env.typ.RelationalExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ relational_expression \>  shift_expression                                                            f:r { { type: env.typ.RelationalExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ relational_expression \<= shift_expression                                                             f:r { { type: env.typ.RelationalExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ relational_expression \>= shift_expression                                                             f:r { { type: env.typ.RelationalExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ relational_expression t:instanceof shift_expression                                                    f:r { { type: env.typ.InstanceOfExpression,  nodes:[$$sym1, $$sym3], pos } }
        │ relational_expression t:in shift_expression                                                            f:r { { type: env.typ.InExpression,  nodes:[$$sym1, $$sym3], pos } }   

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-bitwise-shift-operators
###############################################################################################################

    <> shift_expression > additive_expression 
        │ shift_expression \<< additive_expression                                                               f:r { { type: env.typ.ShiftExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ shift_expression \>> additive_expression                                                               f:r { { type: env.typ.ShiftExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ shift_expression \>>> additive_expression                                                              f:r { { type: env.typ.ShiftExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-additive-operators
###############################################################################################################

    <> additive_expression > multiplicative_expression 
        │ additive_expression + multiplicative_expression                                                       f:r { { type: env.typ.AdditiveExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ additive_expression - multiplicative_expression                                                       f:r { { type: env.typ.AdditiveExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-multiplicative-operators
###############################################################################################################

    <> multiplicative_expression > exponentiation_expression 
        │ multiplicative_expression * exponentiation_expression                                                 f:r { { type: env.typ.MultiplicativeExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ multiplicative_expression / exponentiation_expression                                                 f:r { { type: env.typ.MultiplicativeExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ multiplicative_expression % exponentiation_expression                                                 f:r { { type: env.typ.MultiplicativeExpression, symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-exp-operator
###############################################################################################################

    <> exponentiation_expression > unary_expression 
        │ update_expression \** exponentiation_expression                                                        f:r { { type: env.typ.ExponentiationExpression, nodes:[$$sym1, $$sym3], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-unary-operators
###############################################################################################################

    <> unary_expression > update_expression 
        │ t:delete unary_expression                                                                              f:r { { type: env.typ.DeleteExpression, nodes:[$$sym2], pos } }
        │ t:void unary_expression                                                                                f:r { { type: env.typ.VoidExpression, nodes:[$$sym2], pos } }
        │ t:typeof unary_expression                                                                              f:r { { type: env.typ.TypeofExpression, nodes:[$$sym2], pos } }
        │ + unary_expression                                                                                    f:r { { type: env.typ.UnaryExpression, symbol:$sym1, nodes:[$$sym2], pos } }
        │ ~ unary_expression                                                                                    f:r { { type: env.typ.UnaryExpression, symbol:$sym1, nodes:[$$sym2], pos } }
        │ ! unary_expression                                                                                    f:r { { type: env.typ.UnaryExpression, symbol:$sym1, nodes:[$$sym2], pos } }
        │ - unary_expression                                                                                    f:r { 
                                                                                                                        ($$sym2.type == env.typ.NumericLiteral || $$sym2.type == env.typ.BigIntLiteral)
                                                                                                                        ? ($$sym2.NEGATIVE = true, $$sym2)
                                                                                                                        : ({ type: env.typ.UnaryExpression, symbol:$sym1, nodes:[$$sym2], pos }) 
                                                                                                                }
        │ await_expression

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-update-expressions
###############################################################################################################

    <> update_expression >  left_hand_side_expression 
        │ left_hand_side_expression  \++                                                                         f:r { { type: env.typ.PostExpression, symbol:$$sym2, nodes:[$$sym1], pos } }
        │ left_hand_side_expression  \--                                                                         f:r { { type: env.typ.PostExpression, symbol:$$sym2, nodes:[$$sym1], pos } }
        │ \++ unary_expression                                                                                   f:r { { type: env.typ.PreExpression, symbol:$$sym1, nodes:[$$sym2], pos } }
        │ \-- unary_expression                                                                                   f:r { { type: env.typ.PreExpression, symbol:$$sym1, nodes:[$$sym2], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#prod-CoverParenthesizedExpressionAndArrowParameterList
###############################################################################################################

    <> cover_parenthesized_expression_and_arrow_parameter_list > \( \)                                          f:r { { type: env.typ.Parenthesized, nodes:[], pos } }
        │ \( expression , \)                                                                                    f:r { { type: env.typ.Parenthesized, nodes:[$$sym2], pos } }
        │ \( ( \... binding_identifier f:r=>Spread)  \)                                                          f:r { { type: env.typ.Parenthesized, nodes:[$$sym2], pos } }
        │ \( ( \... binding_pattern f:r=>Spread) \)                                                              f:r { { type: env.typ.Parenthesized, nodes:[$$sym2], pos } }
        │ \( expression , ( \... binding_identifier f:r=>Spread)  \)                                             f:r { { type: env.typ.Parenthesized, nodes:[$$sym2, $$sym4], pos } }
        │ \( expression , ( \... binding_pattern f:r=>Spread)  \)                                                f:r { { type: env.typ.Parenthesized, nodes:[$$sym2, $$sym4], pos } }                                                                                       
        │ parenthesized                                                                                         
    
    <> parenthesized > \( expression \)                                                                         f:r { { type: env.typ.Parenthesized, nodes:[$$sym2], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#prod-BindingPattern
###############################################################################################################

    <> binding_pattern > object_binding_pattern
        │   array_binding_pattern

    <> object_binding_pattern > { }                                                                             f:r { { type: env.typ.ObjectBinding, nodes:[], pos } }
        │ { binding_rest_property }                                                                             f:r { { type: env.typ.ObjectBinding, nodes:[$sym2], pos } }
        │ { binding_property_list  }                                                                            f:r { { type: env.typ.ObjectBinding, nodes:[...$sym2], pos } }    
        │ { binding_property_list , binding_rest_property? }                                                    f:r { { type: env.typ.ObjectBinding, nodes:[...$sym2, $sym4], pos } }    

    <> array_binding_pattern > 
        \[ elision? binding_rest_element? \]                                                                    f:r { { type: env.typ.ArrayBinding, nodes:[$sym2, $sym3], pos } }
        │ \[ binding_element_list \]                                                                            f:r { { type: env.typ.ArrayBinding, nodes:[...$sym2], pos } }    
        │ \[ binding_element_list , elision? binding_rest_element? \]                                            f:r { { type: env.typ.ArrayBinding, nodes:[...$sym2, $sym4, $sym5], pos } }    

    <> binding_property_list > binding_property                                                                 f:r { [$$sym1] }
        | binding_property_list \, binding_property                                                             f:r { [...$$sym1, $sym3] }
    
    <> binding_element_list > binding_elision_element                                                           
        | binding_element_list \, binding_elision_element                                                       f:r { [...$$sym1, ...$sym3] }

    <> binding_elision_element > elision? binding_element                                                       f:r { [$sym1, $sym2] }                                                    

    <> binding_property > single_name_binding 
        │ property_name : binding_element                                                                       f:r { { type:env.typ.PropertyBinding, nodes:[$sym1, $sym3],  pos  } }  

    <> binding_element > single_name_binding
        │ binding_pattern initializer?                                                                           f:r { $$sym2 ? { type:env.typ.BindingExpression, nodes: [$sym1, $sym2],  pos  } : $sym1 }

    <> single_name_binding > binding_identifier initializer?                                                     f:r { $$sym2 ? { type:env.typ.BindingExpression, nodes: [$sym1, $sym2],  pos  } : $sym1 }

    <> binding_rest_property > \... binding_identifier                                                           f:r=>Spread
    <> binding_rest_element > \... binding_identifier                                                            f:r=>Spread
        │ \... binding_pattern                                                                                   f:r=>Spread                                                                                              


###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#prod-RegularExpressionLiteral
###############################################################################################################

    <> regular_expression_literal > ↦^parseRegex \/ \/ def::js_identifier?                                      f:r { { type:env.typ.RegexLiteral, value:$sym1, flags:$sym3,  pos  } }

    <> regular_expression_flags > identifier_name  

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-object-initializer
###############################################################################################################

    <> object_literal >  { }                                                                                    f:r { { type:env.typ.ObjectLiteral, nodes:[],  pos  } }
        │ { property_definition_list ,? }                                                                       f:r { { type:env.typ.ObjectLiteral, nodes:$sym2,  pos  } }

    <> property_definition_list > property_definition                                                           f:r { [$sym1] }
        │ property_definition_list , property_definition                                                        f:r { $sym1.push($sym3), $sym1 }       

    <> property_definition >  cover_initialized_name                
        │ identifier_reference                                                                                  f:r { $sym1.type |= env.cls.PROPERTY_NAME, $sym1 }
        │ method_definition                                                                                     
        │ \... assignment_expression                                                                            f:r =>Spread
        │ property_name : assignment_expression                                                                 f:r { { type:env.typ.PropertyBinding, nodes:[$sym1, $sym3],  pos  } }       

    <> property_name > literal_property_name                                                                    f:r { $sym1.type |= env.cls.PROPERTY_NAME, $sym1 }
        │ computed_property_name                                                                                f:r { $sym1.type |= env.cls.PROPERTY_NAME, $sym1 }

    <> literal_property_name > identifier_name                                                                  
        │ string_literal
        │ numeric_literal

    <> computed_property_name > \[ assignment_expression \]                                                     f:r { { type: env.typ.ComputedProperty, nodes:[$sym2], pos } }

    <> cover_initialized_name > identifier_reference initializer                                                f:{ sym[sym.length-2].type |= env.cls.PROPERTY_NAME } f:r=>BindingExpression

    <> initializer > = assignment_expression                                                                    f:r { $sym2 }
    

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-array-initializer
###############################################################################################################

    <> array_literal > \[ elision? \]                                                                           f:r { { type: env.typ.ArrayLiteral, nodes:[$sym2], pos } }
        │ \[ element_list \]                                                                                    f:r { { type: env.typ.ArrayLiteral, nodes:$$sym2, pos } }
        │ \[ element_list , elision? \]                                                                         f:r { { type: env.typ.ArrayLiteral, nodes:[...$$sym2, $sym4], pos } }

    <> element_list > elision? assignment_expression                                                            f:r { [$sym1, $sym2 ] }
        │ elision? spread_element                                                                               f:r { [ $sym1,$sym2 ] }
        │ element_list , elision? assignment_expression                                                         f:r { [ ...$sym1, $sym3, $sym4 ] }
        │ element_list , elision? spread_element                                                                f:r { [ ...$sym1, $sym3, $sym4 ] }

    <> elision > ,                                                                                              f:r { { type: env.typ.Elision, count:0, pos } }
        │ elision ,                                                                                             f:r { { type: env.typ.Elision, count:$sym1.count+1, pos } }

    <> spread_element > \... assignment_expression                                                              f:r=>Spread

###############################################################################################################
#https://www.ecma-international.org/ecma-262/#prod-TemplateLiteral
###############################################################################################################

    <> template_literal > no_substitute_template
        │ substitute_template 

    <> no_substitute_template > \``                                                                             f:r { { type: env.typ.Template, nodes:[ { quote_type:"", type: env.typ.StringLiteral, value:$sym1,  pos  }], NO_SUBSTITUTE:true, pos } }

    <> substitute_template > template_head expression template_spans                                            f:r { $sym3.unshift($sym1, $sym2), { type: env.typ.Template, nodes:$$sym3, pos } }

    <> template_spans > template_tail                                                                           f:r { [ $sym1 ] }
        │ template_middle_list template_tail                                                                    f:r { $sym1.push($sym2), $sym1 }           

    <> template_middle_list > template_middle expression                                                        f:r { [ $sym1, $sym2 ] }
        │ template_middle_list template_middle expression                                                       f:r { $sym1.push($sym2, $sym3), $sym1 }

    <> template_head >       ` string_data(*\" ) \${                                                             f:r { { type:env.typ.TemplateHead, value:$sym2, pos  } }

    <> template_middle >    \} string_data(*\" ) \${                                                             f:r { { type:env.typ.TemplateMiddle, value:$sym2,  pos  } }

    <> template_tail >      \} string_data(*\" ) `                                                               f:r { { type:env.typ.TemplateTail, value:$sym2,  pos  } }
    
    <> template_string_data >  g:nl │ g:ws │ g:sym │ g:num │ g:id escaped_sequence                                      
                                                                                                              

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-ecmascript-language-lexical-grammar
###############################################################################################################

    <> literal > boolean_literal                
        │ null_literal
        │ string_literal                    
        │ numeric_literal
        │ bigint       

    <> string_literal > \" string_data(*\" ) \"                                                                       f:r { { quote_type:$sym1, type: env.typ.StringLiteral, value:$$sym2,  pos  } }
        │ \' string_data(*\" ) \'                                                                                     f:r { { quote_type:$sym1, type: env.typ.StringLiteral, value:$$sym2,  pos  } }

    <> string_data >   g:nl │ g:ws │ g:sym │ g:num │ g:id | escaped_sequence                     

    <> escaped_sequence > \\ (  g:nl │ g:ws │ g:sym │ g:num │ g:id  )
                                                                                                                f:r { $sym1 + $sym2}

    #<> hex_escape_sequence > t:x g:num                                                                        f:r { $sym1 + $sym2 + $sym3 }

    #<> unicode_escape_sequence > t:u g:num                                                                    f:r { $sym1 + $sym2 + $sym3 + $sym4 + $sym5 }
    #    │ t:u \{ g:num \}                                                                                     f:r { $sym1 + $sym2 + $sym3 + $sym4 }

    <> bigint >  g:num t:n                                                                                     f:r { { type: env.typ.BigIntLiteral, value:$sym1, pos, NEGATIVE:false } }                                                        
    
    <> numeric_literal > g:num                                                                                  f:r { { type: env.typ.NumericLiteral, value:$sym1, computed_value:parseFloat($sym1), value_data:$sym2, pos, NEGATIVE:false } }

    <> null_literal >  t:null                                                                                    f:r { { type: env.typ.NullLiteral, pos  } }

    <> boolean_literal > t:true                                                                                  f:r { { type: env.typ.BooleanLiteral, value: $$sym1,  pos  } }
        │ t:false                                                                                                f:r { { type: env.typ.BooleanLiteral, value: $$sym1,  pos  } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/11.0/index.html#sec-names-and-keywords
###############################################################################################################

    <> label_identifier > identifier                                                                            f:r { $sym1.type = env.typ.IdentifierLabel, $sym1 }   
            #│ t:yield                          
            #│ t:await                           

    <> identifier_reference > identifier                                                                        f:r { $sym1.type = env.typ.IdentifierReference, $sym1 }
            #│ t:yield                               
            #│ t:await                               

    <> binding_identifier > identifier                                                                          f:r { $sym1.type = env.typ.IdentifierBinding, $sym1 }
            #│ t:yield                               
            #│ t:await                               

    <> identifier > composite_identifier                                                                        f:r { { type: env.typ.Identifier, value:$sym1,  pos  } }   
        │ unreserved_word                                                                                       f:r { { type: env.typ.Identifier, value:$sym1,  pos  } }   

    <> identifier_name > composite_identifier                                                                    f:r { { type: env.typ.IdentifierName, value:$sym1,  pos  } }              
        │ reserved_word                                                                                         f:r { { type: env.typ.IdentifierName, value:$sym1,  pos  } } 
        │ unreserved_word                                                                                       f:r { { type: env.typ.IdentifierName, value:$sym1,  pos  } }

    <> unreserved_word > t:async
        │ t:get
        │ t:set
        │ t:target
        │ t:as
        │ t:from


    <> reserved_word >  keyword
        │ future_reserved_word
        │ t:null
        │ t:true 
        │ t:false                                                                                                               

    <> future_reserved_word > t:implements 
        │ t:package 
        │ t:protected 
        │ t:interface
        │ t:private
        │ t:public

    <> composite_identifier > def::js_identifier 

    <> keyword > t:await
        │ t:break
        │ t:case
        │ t:catch
        │ t:class
        │ t:const
        │ t:continue
        │ t:debugger
        │ t:default
        │ t:delete
        │ t:do
        │ t:else
        │ t:export
        │ t:extends
        │ t:finally
        │ t:for
        │ t:function
        │ t:if
        │ t:import
        │ t:in
        │ t:instanceof
        │ t:new
        │ t:return
        │ t:super
        │ t:switch
        │ t:this
        │ t:throw
        │ t:try
        │ t:typeof
        │ t:var
        │ t:void
        │ t:while
        │ t:with
        │ t:yield



