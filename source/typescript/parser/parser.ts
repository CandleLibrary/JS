
import {
    ParserFactoryGamma as ParserFactory
} from "@candlelib/hydrocarbon";
import URI from "@candlelib/uri";;

const wasm_recognizer = URI.resolveRelative("./parser.wasm", URI.getEXEURL(import.meta)),

    reduce_functions = [(_, s) => s[s.length - 1], (env, sym, pos) => (env.IS_MODULE = false, sym[0]) /*0*/,
    (env, sym, pos) => ({ type: (env.IS_MODULE) ? env.typ.Module : env.typ.Script, nodes: sym[0] || [], pos }) /*1*/,
    (env, sym, pos) => ({ type: (env.IS_MODULE) ? env.typ.Module : env.typ.Script, nodes: [], pos }) /*2*/,
    (env, sym, pos) => ([sym[0]]) /*3*/,
    (env, sym, pos) => ((sym[0].push(sym[1]), sym[0])) /*4*/,
    (env, sym, pos) => (env.IS_MODULE = true, sym[0]) /*5*/,
    (env, sym, pos) => ({ type: env.typ.ImportDeclaration, nodes: [sym[1], sym[2]], pos }) /*6*/,
    (env, sym, pos) => ({ type: env.typ.ImportDeclaration, nodes: [sym[1]], pos }) /*7*/,
    (env, sym, pos) => ({ type: env.typ.ImportClause, nodes: [sym[0]], pos }) /*8*/,
    (env, sym, pos) => ({ type: env.typ.ImportClause, nodes: [sym[0], sym[2]], pos }) /*9*/,
    (env, sym, pos) => (sym[0].type = env.typ.IdentifierDefault, sym[0]) /*10*/,
    (env, sym, pos) => ({ type: env.typ.NameSpaceImport, nodes: [sym[2]], pos }) /*11*/,
    (env, sym, pos) => ({ type: env.typ.NamedImports, nodes: sym[1] || [], pos }) /*12*/,
    (env, sym, pos) => ({ type: env.typ.NamedImports, nodes: null || [], pos }) /*13*/,
    (env, sym, pos) => ({ type: env.typ.FromClause, nodes: [sym[1]], pos }) /*14*/,
    (env, sym, pos) => ({ type: env.typ.Specifier, nodes: [sym[0]], pos }) /*15*/,
    (env, sym, pos) => ({ type: env.typ.Specifier, nodes: [sym[0], sym[2]], pos }) /*16*/,
    (env, sym, pos) => (sym[0].type = env.typ.IdentifierModule, sym[0]) /*17*/,
    (env, sym, pos) => ({ type: env.typ.ExportDeclaration, nodes: [null, sym[2]], DEFAULT: false, pos }) /*18*/,
    (env, sym, pos) => ({ type: env.typ.ExportDeclaration, nodes: [sym[1], sym[2]], DEFAULT: false, pos }) /*19*/,
    (env, sym, pos) => ({ type: env.typ.ExportDeclaration, nodes: [sym[1]], DEFAULT: false, pos }) /*20*/,
    (env, sym, pos) => ({ type: env.typ.ExportDeclaration, nodes: [sym[2]], DEFAULT: true, pos }) /*21*/,
    (env, sym, pos) => ({ type: env.typ.ExportDeclaration, nodes: [sym[1], null], DEFAULT: false, pos }) /*22*/,
    (env, sym, pos) => ({ type: env.typ.ExportClause, nodes: sym[1] || [], pos }) /*23*/,
    (env, sym, pos) => ({ type: env.typ.ExportClause, nodes: null || [], pos }) /*24*/,
    (env, sym, pos) => ({ type: env.typ.Script, nodes: sym[0], pos }) /*25*/,
    (env, sym, pos) => ([...sym[0], sym[1]]) /*26*/,
    (env, sym, pos) => ({ type: env.typ.BlockStatement, nodes: sym[1] || [], pos }) /*27*/,
    (env, sym, pos) => ({ type: env.typ.BlockStatement, nodes: null || [], pos }) /*28*/,
    (env, sym, pos) => ({ type: env.typ.EmptyStatement, pos }) /*29*/,
    (env, sym, pos) => ({ type: env.typ.ExpressionStatement, nodes: [sym[0]], pos }) /*30*/,
    (env, sym, pos) => ({ type: env.typ.IfStatement, nodes: [sym[2], sym[4], sym[6]], pos }) /*31*/,
    (env, sym, pos) => ({ type: env.typ.IfStatement, nodes: [sym[2], sym[4], null], pos }) /*32*/,
    (env, sym, pos) => ({ type: env.typ.DoStatement, nodes: [sym[1], sym[4]], pos }) /*33*/,
    (env, sym, pos) => ({ type: env.typ.WhileStatement, nodes: [sym[2], sym[4]], pos }) /*34*/,
    (env, sym, pos) => ({ type: env.typ.ForStatement, nodes: [sym[2], sym[4], sym[6], sym[8]], LEX: false, pos }) /*35*/,
    (env, sym, pos) => ({ type: env.typ.ForStatement, nodes: [sym[2], sym[3], sym[5], sym[7]], LEX: true, pos }) /*36*/,
    (env, sym, pos) => ({ type: env.typ.ForInStatement, nodes: [sym[2], sym[4], sym[6]], pos }) /*37*/,
    (env, sym, pos) => ({ type: env.typ.ForOfStatement, nodes: [sym[3], sym[5], sym[7]], pos, AWAIT: !!sym[1] }) /*38*/,
    (env, sym, pos) => ({ type: env.typ.ForStatement, nodes: [null, sym[3], sym[5], sym[7]], LEX: false, pos }) /*39*/,
    (env, sym, pos) => ({ type: env.typ.ForStatement, nodes: [sym[2], null, sym[5], sym[7]], LEX: false, pos }) /*40*/,
    (env, sym, pos) => ({ type: env.typ.ForStatement, nodes: [sym[2], sym[4], null, sym[7]], LEX: false, pos }) /*41*/,
    (env, sym, pos) => ({ type: env.typ.ForStatement, nodes: [sym[2], null, sym[4], sym[6]], LEX: true, pos }) /*42*/,
    (env, sym, pos) => ({ type: env.typ.ForStatement, nodes: [sym[2], sym[3], null, sym[6]], LEX: true, pos }) /*43*/,
    (env, sym, pos) => ({ type: env.typ.ForOfStatement, nodes: [sym[2], sym[4], sym[6]], pos, AWAIT: !!null }) /*44*/,
    (env, sym, pos) => ({ type: env.typ.ForStatement, nodes: [null, null, sym[4], sym[6]], LEX: false, pos }) /*45*/,
    (env, sym, pos) => ({ type: env.typ.ForStatement, nodes: [null, sym[3], null, sym[6]], LEX: false, pos }) /*46*/,
    (env, sym, pos) => ({ type: env.typ.ForStatement, nodes: [sym[2], null, null, sym[6]], LEX: false, pos }) /*47*/,
    (env, sym, pos) => ({ type: env.typ.ForStatement, nodes: [sym[2], null, null, sym[5]], LEX: true, pos }) /*48*/,
    (env, sym, pos) => ({ type: env.typ.ForStatement, nodes: [null, null, null, sym[5]], LEX: false, pos }) /*49*/,
    (env, sym, pos) => ({ type: env.typ.LexicalBinding, nodes: [sym[1]], symbol: sym[0], pos }) /*50*/,
    (env, sym, pos) => ({ type: env.typ.ContinueStatement, nodes: sym[1] ? [sym[1]] : [], pos }) /*51*/,
    (env, sym, pos) => ({ type: env.typ.ContinueStatement, nodes: null ? [null] : [], pos }) /*52*/,
    (env, sym, pos) => ({ type: env.typ.BreakStatement, nodes: [sym[1]], pos }) /*53*/,
    (env, sym, pos) => ({ type: env.typ.BreakStatement, nodes: [null], pos }) /*54*/,
    (env, sym, pos) => ({ type: env.typ.ReturnStatement, nodes: [sym[1]], pos }) /*55*/,
    (env, sym, pos) => ({ type: env.typ.ReturnStatement, nodes: [], pos }) /*56*/,
    (env, sym, pos) => ({ type: env.typ.ThrowStatement, nodes: [sym[1]], pos }) /*57*/,
    (env, sym, pos) => ({ type: env.typ.WithStatement, nodes: [sym[2], sym[4]], pos }) /*58*/,
    (env, sym, pos) => ({ type: env.typ.SwitchStatement, nodes: [sym[2], sym[4]], pos }) /*59*/,
    (env, sym, pos) => ({ type: env.typ.CaseBlock, nodes: [...sym[1], sym[2], ...sym[3]], pos }) /*60*/,
    (env, sym, pos) => ({ type: env.typ.CaseBlock, nodes: [sym[1], ...sym[2]], pos }) /*61*/,
    (env, sym, pos) => ({ type: env.typ.CaseBlock, nodes: [...sym[1], ...sym[2]], pos }) /*62*/,
    (env, sym, pos) => ({ type: env.typ.CaseBlock, nodes: [...sym[1], sym[2]], pos }) /*63*/,
    (env, sym, pos) => ({ type: env.typ.CaseBlock, nodes: [...sym[1]], pos }) /*64*/,
    (env, sym, pos) => ({ type: env.typ.CaseBlock, nodes: [sym[1]], pos }) /*65*/,
    (env, sym, pos) => ({ type: env.typ.CaseBlock, nodes: [], pos }) /*66*/,
    (env, sym, pos) => ({ type: env.typ.CaseClause, nodes: [sym[1], ...sym[3]], pos }) /*67*/,
    (env, sym, pos) => ({ type: env.typ.CaseClause, nodes: [sym[1]], pos }) /*68*/,
    (env, sym, pos) => ({ type: env.typ.DefaultClause, nodes: [...sym[2]], pos }) /*69*/,
    (env, sym, pos) => ({ type: env.typ.DefaultClause, nodes: [], pos }) /*70*/,
    (env, sym, pos) => ({ type: env.typ.LabeledStatement, nodes: [sym[0], sym[2]], pos }) /*71*/,
    (env, sym, pos) => ({ type: env.typ.TryStatement, nodes: [sym[1], sym[2], null], pos }) /*72*/,
    (env, sym, pos) => ({ type: env.typ.TryStatement, nodes: [sym[1], null, sym[2]], pos }) /*73*/,
    (env, sym, pos) => ({ type: env.typ.TryStatement, nodes: [sym[1], sym[2], sym[3]], pos }) /*74*/,
    (env, sym, pos) => ({ type: env.typ.CatchClause, nodes: [sym[2], sym[4]], pos }) /*75*/,
    (env, sym, pos) => ({ type: env.typ.FinallyClause, nodes: [sym[1]], pos }) /*76*/,
    (env, sym, pos) => ({ type: env.typ.DebuggerStatement, pos }) /*77*/,
    (env, sym, pos) => ({ type: env.typ.VariableStatement, nodes: sym[1], pos }) /*78*/,
    (env, sym, pos) => ((sym[0].push(sym[2]), sym[0])) /*79*/,
    (env, sym, pos) => ({ type: env.typ.BindingExpression, symbol: "=", nodes: [sym[0], sym[1]], pos }) /*80*/,
    (env, sym, pos) => ({ type: env.typ.LexicalDeclaration, symbol: sym[0], nodes: sym[1], pos }) /*81*/,
    (env, sym, pos) => ("let") /*82*/,
    (env, sym, pos) => ("const") /*83*/,
    (env, sym, pos) => ({ type: env.typ.FunctionDeclaration, ASYNC: !!sym[0], GENERATOR: !!sym[2], nodes: [sym[3], sym[5], sym[8]], pos }) /*84*/,
    (env, sym, pos) => ({ type: env.typ.FunctionDeclaration, ASYNC: !!null, GENERATOR: !!sym[1], nodes: [sym[2], sym[4], sym[7]], pos }) /*85*/,
    (env, sym, pos) => ({ type: env.typ.FunctionDeclaration, ASYNC: !!sym[0], GENERATOR: !!null, nodes: [sym[2], sym[4], sym[7]], pos }) /*86*/,
    (env, sym, pos) => ({ type: env.typ.FunctionDeclaration, ASYNC: !!sym[0], GENERATOR: !!sym[2], nodes: [null, sym[4], sym[7]], pos }) /*87*/,
    (env, sym, pos) => ({ type: env.typ.FunctionDeclaration, ASYNC: !!sym[0], GENERATOR: !!sym[2], nodes: [sym[3], null, sym[7]], pos }) /*88*/,
    (env, sym, pos) => ({ type: env.typ.FunctionDeclaration, ASYNC: !!null, GENERATOR: !!null, nodes: [sym[1], sym[3], sym[6]], pos }) /*89*/,
    (env, sym, pos) => ({ type: env.typ.FunctionDeclaration, ASYNC: !!null, GENERATOR: !!sym[1], nodes: [null, sym[3], sym[6]], pos }) /*90*/,
    (env, sym, pos) => ({ type: env.typ.FunctionDeclaration, ASYNC: !!null, GENERATOR: !!sym[1], nodes: [sym[2], null, sym[6]], pos }) /*91*/,
    (env, sym, pos) => ({ type: env.typ.FunctionDeclaration, ASYNC: !!sym[0], GENERATOR: !!null, nodes: [null, sym[3], sym[6]], pos }) /*92*/,
    (env, sym, pos) => ({ type: env.typ.FunctionDeclaration, ASYNC: !!sym[0], GENERATOR: !!null, nodes: [sym[2], null, sym[6]], pos }) /*93*/,
    (env, sym, pos) => ({ type: env.typ.FunctionDeclaration, ASYNC: !!sym[0], GENERATOR: !!sym[2], nodes: [null, null, sym[6]], pos }) /*94*/,
    (env, sym, pos) => ({ type: env.typ.FunctionDeclaration, ASYNC: !!null, GENERATOR: !!null, nodes: [null, sym[2], sym[5]], pos }) /*95*/,
    (env, sym, pos) => ({ type: env.typ.FunctionDeclaration, ASYNC: !!null, GENERATOR: !!null, nodes: [sym[1], null, sym[5]], pos }) /*96*/,
    (env, sym, pos) => ({ type: env.typ.FunctionDeclaration, ASYNC: !!null, GENERATOR: !!sym[1], nodes: [null, null, sym[5]], pos }) /*97*/,
    (env, sym, pos) => ({ type: env.typ.FunctionDeclaration, ASYNC: !!sym[0], GENERATOR: !!null, nodes: [null, null, sym[5]], pos }) /*98*/,
    (env, sym, pos) => ({ type: env.typ.FunctionDeclaration, ASYNC: !!null, GENERATOR: !!null, nodes: [null, null, sym[4]], pos }) /*99*/,
    (env, sym, pos) => ((sym[0].type = env.typ.FunctionExpression, sym[0])) /*100*/,
    (env, sym, pos) => ({ type: env.typ.FormalParameters, nodes: [sym[0]], pos }) /*101*/,
    (env, sym, pos) => ({ type: env.typ.FormalParameters, nodes: sym[0], pos }) /*102*/,
    (env, sym, pos) => ({ type: env.typ.FormalParameters, nodes: [...sym[0], sym[2]], pos }) /*103*/,
    (env, sym, pos) => ({ type: env.typ.FunctionBody, nodes: sym[0] || [], pos }) /*104*/,
    (env, sym, pos) => ({ type: env.typ.YieldExpression, nodes: [], pos }) /*105*/,
    (env, sym, pos) => ({ type: env.typ.YieldExpression, nodes: [sym[2]], pos, GENERATOR: !!sym[1] }) /*106*/,
    (env, sym, pos) => ({ type: env.typ.YieldExpression, nodes: [sym[1]], pos, GENERATOR: !!null }) /*107*/,
    (env, sym, pos) => ({ type: env.typ.ArrowFunction, ASYNC: !!sym[0], nodes: [sym[1], sym[3]], pos }) /*108*/,
    (env, sym, pos) => ({ type: env.typ.ArrowFunction, ASYNC: !!null, nodes: [sym[0], sym[2]], pos }) /*109*/,
    (env, sym, pos) => (sym[0].type = env.typ.IdentifierBinding, sym[0]) /*110*/,
    (env, sym, pos) => ({ type: env.typ.BlockStatement, nodes: sym[1], pos }) /*111*/,
    (env, sym, pos) => ({ type: env.typ.CallExpression, nodes: [sym[0], sym[1]], pos }) /*112*/,
    (env, sym, pos) => ({ type: env.typ.Class, nodes: [sym[1], sym[2], ...sym[4]], pos }) /*113*/,
    (env, sym, pos) => ({ type: env.typ.Class, nodes: [null, sym[1], ...sym[3]], pos }) /*114*/,
    (env, sym, pos) => ({ type: env.typ.Class, nodes: [sym[1], null, ...sym[3]], pos }) /*115*/,
    (env, sym, pos) => ({ type: env.typ.Class, nodes: [sym[1], sym[2]], pos }) /*116*/,
    (env, sym, pos) => ({ type: env.typ.Class, nodes: [null, null, ...sym[2]], pos }) /*117*/,
    (env, sym, pos) => ({ type: env.typ.Class, nodes: [null, sym[1]], pos }) /*118*/,
    (env, sym, pos) => ({ type: env.typ.Class, nodes: [sym[1], null], pos }) /*119*/,
    (env, sym, pos) => ({ type: env.typ.Class, nodes: [null, null], pos }) /*120*/,
    (env, sym, pos) => (sym[0].concat(sym[1])) /*121*/,
    (env, sym, pos) => ([]) /*122*/,
    (env, sym, pos) => ((sym[1].STATIC = true, sym[1])) /*123*/,
    (env, sym, pos) => ({ type: env.typ.Method, ASYNC: !!sym[0], GENERATOR: !!sym[1], nodes: [sym[2], sym[4], sym[7]], pos }) /*124*/,
    (env, sym, pos) => ({ type: env.typ.GetterMethod, nodes: [sym[1], sym[5]], pos }) /*125*/,
    (env, sym, pos) => ({ type: env.typ.SetterMethod, nodes: [sym[1], sym[3], sym[6]], pos }) /*126*/,
    (env, sym, pos) => ({ type: env.typ.Method, ASYNC: !!null, GENERATOR: !!sym[0], nodes: [sym[1], sym[3], sym[6]], pos }) /*127*/,
    (env, sym, pos) => ({ type: env.typ.Method, ASYNC: !!sym[0], GENERATOR: !!null, nodes: [sym[1], sym[3], sym[6]], pos }) /*128*/,
    (env, sym, pos) => ({ type: env.typ.Method, ASYNC: !!sym[0], GENERATOR: !!sym[1], nodes: [sym[2], null, sym[6]], pos }) /*129*/,
    (env, sym, pos) => ({ type: env.typ.Method, ASYNC: !!sym[0], GENERATOR: !!sym[1], nodes: [sym[2], sym[4], null], pos }) /*130*/,
    (env, sym, pos) => ({ type: env.typ.GetterMethod, nodes: [sym[1]], pos }) /*131*/,
    (env, sym, pos) => ({ type: env.typ.SetterMethod, nodes: [sym[1], sym[3]], pos }) /*132*/,
    (env, sym, pos) => ({ type: env.typ.Method, ASYNC: !!null, GENERATOR: !!null, nodes: [sym[0], sym[2], sym[5]], pos }) /*133*/,
    (env, sym, pos) => ({ type: env.typ.Method, ASYNC: !!null, GENERATOR: !!sym[0], nodes: [sym[1], null, sym[5]], pos }) /*134*/,
    (env, sym, pos) => ({ type: env.typ.Method, ASYNC: !!null, GENERATOR: !!sym[0], nodes: [sym[1], sym[3], null], pos }) /*135*/,
    (env, sym, pos) => ({ type: env.typ.Method, ASYNC: !!sym[0], GENERATOR: !!null, nodes: [sym[1], null, sym[5]], pos }) /*136*/,
    (env, sym, pos) => ({ type: env.typ.Method, ASYNC: !!sym[0], GENERATOR: !!null, nodes: [sym[1], sym[3], null], pos }) /*137*/,
    (env, sym, pos) => ({ type: env.typ.Method, ASYNC: !!sym[0], GENERATOR: !!sym[1], nodes: [sym[2], null, null], pos }) /*138*/,
    (env, sym, pos) => ({ type: env.typ.Method, ASYNC: !!null, GENERATOR: !!null, nodes: [sym[0], null, sym[4]], pos }) /*139*/,
    (env, sym, pos) => ({ type: env.typ.Method, ASYNC: !!null, GENERATOR: !!null, nodes: [sym[0], sym[2], null], pos }) /*140*/,
    (env, sym, pos) => ({ type: env.typ.Method, ASYNC: !!null, GENERATOR: !!sym[0], nodes: [sym[1], null, null], pos }) /*141*/,
    (env, sym, pos) => ({ type: env.typ.Method, ASYNC: !!sym[0], GENERATOR: !!null, nodes: [sym[1], null, null], pos }) /*142*/,
    (env, sym, pos) => ({ type: env.typ.Method, ASYNC: !!null, GENERATOR: !!null, nodes: [sym[0], null, null], pos }) /*143*/,
    (env, sym, pos) => ((sym[0].type == env.typ.ExpressionList ? (sym[0].nodes.push(sym[2]), sym[0]) : { type: env.typ.ExpressionList, nodes: [sym[0], sym[2]], pos })) /*144*/,
    (env, sym, pos) => ({ type: env.typ.MemberExpression, nodes: [sym[0], sym[2]], pos, COMPUTED: true }) /*145*/,
    (env, sym, pos) => ((sym[2].type |= env.cls.PROPERTY_NAME, { type: env.typ.MemberExpression, nodes: [sym[0], sym[2]], pos, COMPUTED: false })) /*146*/,
    (env, sym, pos) => ({ type: env.typ.CallExpression, nodes: [sym[0], sym[1]], pos, TEMPLATE: true }) /*147*/,
    (env, sym, pos) => ({ type: env.typ.NewInstanceExpression, nodes: [sym[1], sym[2]], pos }) /*148*/,
    (env, sym, pos) => ({ type: env.typ.NewExpression, nodes: [sym[1]], pos }) /*149*/,
    (env, sym, pos) => ((sym[2].type |= env.cls.PROPERTY_NAME, { type: env.typ.SuperExpression, nodes: [sym[2]], pos, COMPUTED: false })) /*150*/,
    (env, sym, pos) => ({ type: env.typ.SuperExpression, nodes: [sym[2]], pos, COMPUTED: true }) /*151*/,
    (env, sym, pos) => ({ type: env.typ.ImportMeta, pos }) /*152*/,
    (env, sym, pos) => ({ type: env.typ.NewTarget, pos }) /*153*/,
    (env, sym, pos) => ({ type: env.typ.CallExpression, nodes: [sym[0], sym[1]], pos, TEMPLATE: false }) /*154*/,
    (env, sym, pos) => ({ type: env.typ.CallExpression, nodes: [sym[0], sym[2]], pos, TEMPLATE: true }) /*155*/,
    (env, sym, pos) => ({ type: env.typ.SuperCall, nodes: [sym[1]], pos }) /*156*/,
    (env, sym, pos) => ({ type: env.typ.ImportCall, nodes: [sym[2]], pos }) /*157*/,
    (env, sym, pos) => ({ type: env.typ.Arguments, nodes: sym[1] || [], pos }) /*158*/,
    (env, sym, pos) => ({ type: env.typ.Arguments, nodes: null || [], pos }) /*159*/,
    (env, sym, pos) => ({ type: env.typ.OptionalMemberExpression, nodes: [sym[0], sym[1].type == "computed" ? sym[1].val : sym[1]], pos, COMPUTED: sym[1].type == "computed" }) /*160*/,
    (env, sym, pos) => ({ type: "computed", val: sym[2] }) /*161*/,
    (env, sym, pos) => ({ type: env.typ.ThisLiteral, pos }) /*162*/,
    (env, sym, pos) => ({ type: env.typ.AwaitExpression, nodes: [sym[1]], pos }) /*163*/,
    (env, sym, pos) => ({ type: env.typ.AssignmentExpression, symbol: "=", nodes: [sym[0], sym[2]], pos }) /*164*/,
    (env, sym, pos) => ({ type: env.typ.AssignmentExpression, symbol: sym[1], nodes: [sym[0], sym[2]], pos }) /*165*/,
    (env, sym, pos) => ({ type: env.typ.ConditionalExpression, nodes: [sym[0], sym[2], sym[4]], pos }) /*166*/,
    (env, sym, pos) => ({ type: env.typ.LogicalExpression, symbol: sym[1], nodes: [sym[0], sym[2]], pos }) /*167*/,
    (env, sym, pos) => ({ type: env.typ.CoalesceExpression, nodes: [sym[0], sym[2]], pos }) /*168*/,
    (env, sym, pos) => ({ type: env.typ.BitwiseExpression, symbol: sym[1], nodes: [sym[0], sym[2]], pos }) /*169*/,
    (env, sym, pos) => ({ type: env.typ.EqualityExpression, symbol: sym[1], nodes: [sym[0], sym[2]], pos }) /*170*/,
    (env, sym, pos) => ({ type: env.typ.RelationalExpression, symbol: sym[1], nodes: [sym[0], sym[2]], pos }) /*171*/,
    (env, sym, pos) => ({ type: env.typ.InstanceOfExpression, nodes: [sym[0], sym[2]], pos }) /*172*/,
    (env, sym, pos) => ({ type: env.typ.InExpression, nodes: [sym[0], sym[2]], pos }) /*173*/,
    (env, sym, pos) => ({ type: env.typ.ShiftExpression, symbol: sym[1], nodes: [sym[0], sym[2]], pos }) /*174*/,
    (env, sym, pos) => ({ type: env.typ.AdditiveExpression, symbol: sym[1], nodes: [sym[0], sym[2]], pos }) /*175*/,
    (env, sym, pos) => ({ type: env.typ.MultiplicativeExpression, symbol: sym[1], nodes: [sym[0], sym[2]], pos }) /*176*/,
    (env, sym, pos) => ({ type: env.typ.ExponentiationExpression, nodes: [sym[0], sym[2]], pos }) /*177*/,
    (env, sym, pos) => ({ type: env.typ.DeleteExpression, nodes: [sym[1]], pos }) /*178*/,
    (env, sym, pos) => ({ type: env.typ.VoidExpression, nodes: [sym[1]], pos }) /*179*/,
    (env, sym, pos) => ({ type: env.typ.TypeofExpression, nodes: [sym[1]], pos }) /*180*/,
    (env, sym, pos) => ({ type: env.typ.UnaryExpression, symbol: sym[0], nodes: [sym[1]], pos }) /*181*/,
    (env, sym, pos) => ((sym[1].type == env.typ.NumericLiteral || sym[1].type == env.typ.BigIntLiteral) ? (sym[1].NEGATIVE = true, sym[1]) : ({ type: env.typ.UnaryExpression, symbol: sym[0], nodes: [sym[1]], pos })) /*182*/,
    (env, sym, pos) => ({ type: env.typ.PostExpression, symbol: sym[1], nodes: [sym[0]], pos }) /*183*/,
    (env, sym, pos) => ({ type: env.typ.PreExpression, symbol: sym[0], nodes: [sym[1]], pos }) /*184*/,
    (env, sym, pos) => ({ type: env.typ.Parenthesized, nodes: [], pos }) /*185*/,
    (env, sym, pos) => ({ type: env.typ.Parenthesized, nodes: [sym[1]], pos }) /*186*/,
    (env, sym, pos) => ({ type: env.typ.Parenthesized, nodes: [sym[1], sym[3]], pos }) /*187*/,
    (env, sym, pos) => ({ type: env.typ.ObjectBinding, nodes: [], pos }) /*188*/,
    (env, sym, pos) => ({ type: env.typ.ObjectBinding, nodes: [sym[1]], pos }) /*189*/,
    (env, sym, pos) => ({ type: env.typ.ObjectBinding, nodes: [...sym[1]], pos }) /*190*/,
    (env, sym, pos) => ({ type: env.typ.ObjectBinding, nodes: [...sym[1], sym[3]], pos }) /*191*/,
    (env, sym, pos) => ({ type: env.typ.ArrayBinding, nodes: [sym[1], sym[2]], pos }) /*192*/,
    (env, sym, pos) => ({ type: env.typ.ArrayBinding, nodes: [...sym[1]], pos }) /*193*/,
    (env, sym, pos) => ({ type: env.typ.ArrayBinding, nodes: [...sym[1], sym[3], sym[4]], pos }) /*194*/,
    (env, sym, pos) => ({ type: env.typ.ArrayBinding, nodes: [sym[1]], pos }) /*195*/,
    (env, sym, pos) => ({ type: env.typ.ArrayBinding, nodes: [...sym[1], sym[3]], pos }) /*196*/,
    (env, sym, pos) => ({ type: env.typ.ArrayBinding, nodes: [], pos }) /*197*/,
    (env, sym, pos) => ([...sym[0], sym[2]]) /*198*/,
    (env, sym, pos) => ([...sym[0], ...sym[2]]) /*199*/,
    (env, sym, pos) => ([sym[0], sym[1]]) /*200*/,
    (env, sym, pos) => ({ type: env.typ.PropertyBinding, nodes: [sym[0], sym[2]], pos }) /*201*/,
    (env, sym, pos) => (sym[1] ? { type: env.typ.BindingExpression, symbol: "=", nodes: [sym[0], sym[1]], pos } : sym[0]) /*202*/,
    (env, sym, pos) => (null ? { type: env.typ.BindingExpression, symbol: "=", nodes: [sym[0]], pos } : sym[0]) /*203*/,
    (env, sym, pos) => ({ type: env.typ.Spread, nodes: [sym[1]], pos }) /*204*/,
    (env, sym, pos) => ({ type: env.typ.ObjectLiteral, nodes: [], pos }) /*205*/,
    (env, sym, pos) => ({ type: env.typ.ObjectLiteral, nodes: sym[1], pos }) /*206*/,
    (env, sym, pos) => (sym[0].push(sym[2]), sym[0]) /*207*/,
    (env, sym, pos) => (sym[0].type |= env.cls.PROPERTY_NAME, sym[0]) /*208*/,
    (env, sym, pos) => ({ type: env.typ.ComputedProperty, nodes: [sym[1]], pos }) /*209*/,
    (env, sym, pos) => (sym[0].type |= env.cls.PROPERTY_NAME, { type: env.typ.BindingExpression, symbol: "=", nodes: [sym[0], sym[1]], pos }) /*210*/,
    (env, sym, pos) => (sym[1]) /*211*/,
    (env, sym, pos) => ({ type: env.typ.ArrayLiteral, nodes: [sym[1]], pos }) /*212*/,
    (env, sym, pos) => ({ type: env.typ.ArrayLiteral, nodes: sym[1], pos }) /*213*/,
    (env, sym, pos) => ({ type: env.typ.ArrayLiteral, nodes: [...sym[1], sym[3]], pos }) /*214*/,
    (env, sym, pos) => ({ type: env.typ.ArrayLiteral, nodes: [], pos }) /*215*/,
    (env, sym, pos) => ({ type: env.typ.ArrayLiteral, nodes: [...sym[1]], pos }) /*216*/,
    (env, sym, pos) => ([...sym[0], sym[2], sym[3]]) /*217*/,
    (env, sym, pos) => ({ type: env.typ.Elision, count: 0, pos }) /*218*/,
    (env, sym, pos) => ({ type: env.typ.Elision, count: sym[0].count + 1, pos }) /*219*/,
    (env, sym, pos) => ({ type: env.typ.Template, nodes: [{ quote_type: "", type: env.typ.StringLiteral, value: sym[1], pos }], NO_SUBSTITUTE: true, pos }) /*220*/,
    (env, sym, pos) => (sym[2].unshift(sym[0], sym[1]), { type: env.typ.Template, nodes: sym[2], pos }) /*221*/,
    (env, sym, pos) => (sym[0].push(sym[1]), sym[0]) /*222*/,
    (env, sym, pos) => (sym[0].push(sym[1], sym[2]), sym[0]) /*223*/,
    (env, sym, pos) => ({ type: env.typ.TemplateHead, value: sym[1], pos }) /*224*/,
    (env, sym, pos) => ({ type: env.typ.TemplateMiddle, value: sym[1], pos }) /*225*/,
    (env, sym, pos) => ({ type: env.typ.TemplateTail, value: sym[1], pos }) /*226*/,
    (env, sym, pos) => (sym[0] + sym[1]) /*227*/,
    (env, sym, pos) => ({ type: env.typ.RegexLiteral, value: sym[1], flags: sym[3], pos }) /*228*/,
    (env, sym, pos) => ({ type: env.typ.RegexLiteral, flags: sym[2], pos }) /*229*/,
    (env, sym, pos) => ({ type: env.typ.RegexLiteral, value: sym[1], pos }) /*230*/,
    (env, sym, pos) => ({ type: env.typ.RegexLiteral, pos }) /*231*/,
    (env, sym, pos) => ({ quote_type: sym[0], type: env.typ.StringLiteral, value: sym[1] || "", pos }) /*232*/,
    (env, sym, pos) => ({ quote_type: sym[0], type: env.typ.StringLiteral, value: null || "", pos }) /*233*/,
    (env, sym, pos) => ({ type: env.typ.NumericLiteral, value: sym[0], computed_value: parseFloat(sym[0].replace(/_/g, "")), pos, NEGATIVE: false }) /*234*/,
    (env, sym, pos) => ({ type: env.typ.BigIntLiteral, value: sym[0], computed_value: parseFloat(sym[0].replace(/_/g, "")), pos, NEGATIVE: false }) /*235*/,
    (env, sym, pos) => (sym[0]) /*236*/,
    (env, sym, pos) => (sym[0] + sym[1] + sym[2]) /*237*/,
    (env, sym, pos) => ({ type: env.typ.NullLiteral, pos }) /*238*/,
    (env, sym, pos) => ({ type: env.typ.BooleanLiteral, value: sym[0], pos }) /*239*/,
    (env, sym, pos) => ({ type: env.typ.IdentifierLabel, value: sym[0] }) /*240*/,
    (env, sym, pos) => ({ type: env.typ.IdentifierReference, value: sym[0] }) /*241*/,
    (env, sym, pos) => ({ type: env.typ.IdentifierBinding, value: sym[0] }) /*242*/,
    (env, sym, pos) => ({ type: env.typ.Identifier, value: sym[0], pos }) /*243*/,
    (env, sym, pos) => ({ type: env.typ.IdentifierName, value: sym[0], pos }) /*244*/,
    (env, sym, pos) => ({ type: env.typ.VariableDeclaration, nodes: sym[1], pos }) /*245*/,
    (env, sym, pos) => ({ type: env.typ.VariableDeclaration, nodes: [sym[1]], pos }) /*246*/,
    (env, sym, pos) => (sym[0] + "") /*247*/];

export default ParserFactory
    (reduce_functions, wasm_recognizer, undefined, { javascript: 0, statement_list_item: 1, expression: 2 });