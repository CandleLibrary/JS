//@ts-nocheck
import { JSNodeClass } from "./node_class_type";

/**
 * Template Converted into Node Type const numbers
 */
export const enum JSNodeType {
    AdditiveExpression = JSNodeClass.EXPRESSION | JSNodeClass.BINARY_EXPRESSION,
    Arguments = JSNodeClass.LIST,
    ArrayBinding,
    ArrayLiteral = JSNodeClass.LITERAL,
    ArrowFunction = JSNodeClass.FUNCTION | JSNodeClass.EXPRESSION,
    AssignmentExpression = JSNodeClass.EXPRESSION | JSNodeClass.ASSIGNMENT,
    AwaitExpression = JSNodeClass.EXPRESSION,
    BigIntLiteral = JSNodeClass.LITERAL,
    BindingExpression = JSNodeClass.EXPRESSION | JSNodeClass.ASSIGNMENT,
    BitwiseExpression = JSNodeClass.EXPRESSION,
    BlockStatement = JSNodeClass.STATEMENT | JSNodeClass.BLOCK,
    BooleanLiteral = JSNodeClass.LITERAL,
    BreakStatement = JSNodeClass.STATEMENT,
    CallExpression = JSNodeClass.EXPRESSION,
    CaseBlock = JSNodeClass.BLOCK,
    CaseClause,
    CatchClause,
    ClassDeclaration = JSNodeClass.CLASS | JSNodeClass.STATEMENT | JSNodeClass.DECLARATION | JSNodeClass.HOISTABLE_DECLARATION,
    ClassExpression = JSNodeClass.CLASS | JSNodeClass.EXPRESSION,
    Class = ClassDeclaration,
    CoalesceExpression = JSNodeClass.EXPRESSION,
    ComputedProperty = JSNodeClass.PROPERTY_NAME,
    ConditionalExpression = JSNodeClass.EXPRESSION | JSNodeClass.TERNARY_EXPRESSION,
    ContinueStatement = JSNodeClass.STATEMENT,
    DebuggerStatement = JSNodeClass.STATEMENT,
    DefaultClause,
    DeleteExpression = JSNodeClass.EXPRESSION,
    DoStatement = JSNodeClass.STATEMENT,
    Elision,
    EmptyStatement = JSNodeClass.STATEMENT,
    EqualityExpression = JSNodeClass.EXPRESSION | JSNodeClass.BINARY_EXPRESSION,
    ExponentiationExpression = JSNodeClass.EXPRESSION | JSNodeClass.BINARY_EXPRESSION,
    ExportClause,
    ExportDeclaration = JSNodeClass.STATEMENT | JSNodeClass.MODULE | JSNodeClass.DECLARATION,
    ExpressionList = JSNodeClass.EXPRESSION | JSNodeClass.LIST,
    ExpressionStatement = JSNodeClass.STATEMENT,
    FinallyClause,
    ForInStatement = JSNodeClass.STATEMENT | JSNodeClass.BLOCK,
    FormalParameters = JSNodeClass.LIST,
    ForOfStatement = JSNodeClass.STATEMENT | JSNodeClass.BLOCK,
    ForStatement = JSNodeClass.STATEMENT | JSNodeClass.BLOCK,
    FromClause,
    FunctionBody = JSNodeClass.BLOCK,
    FunctionDeclaration = JSNodeClass.FUNCTION | JSNodeClass.STATEMENT | JSNodeClass.DECLARATION,
    FunctionExpression = JSNodeClass.FUNCTION | JSNodeClass.EXPRESSION | JSNodeClass.DECLARATION,
    GetterMethod = JSNodeClass.METHOD,
    Identifier = JSNodeClass.IDENTIFIER,
    IdentifierBinding = JSNodeClass.VARIABLE | JSNodeClass.IDENTIFIER,
    IdentifierDefault = JSNodeClass.IDENTIFIER | JSNodeClass.MODULE,
    IdentifierLabel = JSNodeClass.IDENTIFIER,
    IdentifierModule = JSNodeClass.IDENTIFIER | JSNodeClass.MODULE,
    IdentifierName = JSNodeClass.IDENTIFIER,
    IdentifierProperty = JSNodeClass.IDENTIFIER | JSNodeClass.PROPERTY_NAME,
    IdentifierReference = JSNodeClass.VARIABLE | JSNodeClass.IDENTIFIER,
    IdentifierReferenceProperty = JSNodeClass.PROPERTY_NAME,
    IfStatement = JSNodeClass.STATEMENT,
    ImportClause,
    ImportDeclaration = JSNodeClass.STATEMENT | JSNodeClass.MODULE | JSNodeClass.DECLARATION,
    ImportMeta = JSNodeClass.EXPRESSION,
    InExpression = JSNodeClass.EXPRESSION | JSNodeClass.BINARY_EXPRESSION,
    InstanceOfExpression = JSNodeClass.BINARY_EXPRESSION | JSNodeClass.EXPRESSION,
    LabeledStatement = JSNodeClass.STATEMENT,
    LexicalBinding,
    ForLexicalDeclaration = JSNodeClass.EXPRESSION | JSNodeClass.DECLARATION,
    LexicalStatement = JSNodeClass.STATEMENT | JSNodeClass.DECLARATION,
    LogicalExpression = JSNodeClass.EXPRESSION | JSNodeClass.BINARY_EXPRESSION,
    MemberExpression = JSNodeClass.EXPRESSION | JSNodeClass.VARIABLE,
    Method,
    Module = JSNodeClass.MODULE,
    MultiplicativeExpression = JSNodeClass.EXPRESSION | JSNodeClass.BINARY_EXPRESSION,
    NamedImports,
    NameSpaceImport,
    NewExpression = JSNodeClass.EXPRESSION,
    NewInstanceExpression = JSNodeClass.EXPRESSION,
    NewTarget = JSNodeClass.LITERAL,
    NullLiteral = JSNodeClass.LITERAL,
    NumericLiteral = JSNodeClass.LITERAL,
    ObjectBinding,
    ObjectLiteral = JSNodeClass.LITERAL,
    OptionalChain,
    OptionalMemberExpression = JSNodeClass.EXPRESSION,
    Parameters = FormalParameters,
    Parenthesized = JSNodeClass.EXPRESSION,
    PostExpression = JSNodeClass.EXPRESSION | JSNodeClass.UNARY_EXPRESSION,
    PreExpression = JSNodeClass.EXPRESSION | JSNodeClass.UNARY_EXPRESSION,
    PropertyBinding = JSNodeClass.ASSIGNMENT,
    RegexLiteral = JSNodeClass.LITERAL,
    RelationalExpression = JSNodeClass.EXPRESSION | JSNodeClass.BINARY_EXPRESSION,
    ReturnStatement = JSNodeClass.STATEMENT,
    Script,
    SetterMethod = JSNodeClass.METHOD,
    ShiftExpression = JSNodeClass.EXPRESSION | JSNodeClass.BINARY_EXPRESSION,
    Specifier = JSNodeClass.BINARY_EXPRESSION,
    Spread = SpreadExpression,
    SpreadExpression = JSNodeClass.EXPRESSION | JSNodeClass.UNARY_EXPRESSION,
    StringLiteral = JSNodeClass.LITERAL,
    SuperCall = JSNodeClass.EXPRESSION,
    SuperExpression = JSNodeClass.EXPRESSION | JSNodeClass.UNARY_EXPRESSION,
    SwitchStatement = JSNodeClass.STATEMENT,
    Template = JSNodeClass.LITERAL | JSNodeClass.TEMPLATE,
    TemplateHead,
    TemplateMiddle,
    TemplateTail,
    ThisLiteral = JSNodeClass.LITERAL,
    ThrowStatement = JSNodeClass.STATEMENT,
    TryStatement = JSNodeClass.STATEMENT,
    TypeofExpression = JSNodeClass.EXPRESSION | JSNodeClass.UNARY_EXPRESSION,
    UnaryExpression = JSNodeClass.EXPRESSION | JSNodeClass.UNARY_EXPRESSION,
    VariableDeclaration = JSNodeClass.LIST | JSNodeClass.DECLARATION,
    VariableStatement = JSNodeClass.LIST | JSNodeClass.DECLARATION | JSNodeClass.STATEMENT | JSNodeClass.HOISTABLE_DECLARATION,
    VoidExpression = JSNodeClass.EXPRESSION | JSNodeClass.UNARY_EXPRESSION,
    WhileStatement = JSNodeClass.STATEMENT,
    WithStatement = JSNodeClass.STATEMENT,
    YieldExpression = JSNodeClass.EXPRESSION | JSNodeClass.UNARY_EXPRESSION,
}
